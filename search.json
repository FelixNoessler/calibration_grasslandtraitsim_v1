[
  {
    "objectID": "parameter_optimized.html",
    "href": "parameter_optimized.html",
    "title": "Optimized parameter",
    "section": "",
    "text": "Code\nusing PrettyTables\n\ninclude(\"scripts/calibration/0_calibration_object.jl\")\nbe_opt = BE_optimization()\n\npretty_table(HTML, [be_opt.parameter_names be_opt.lb be_opt.ub]; \n             header = [\"Parameter\", \"Lower bound\", \"Upper bound\"])\n\n\n\n\n\nParameter\nLower bound\nUpper bound\n\n\n\n\nα_RUE_cwmH\n0.7\n1.0\n\n\nα_WAT_rsa05\n0.7\n0.9999\n\n\nδ_WAT_rsa\n0.1\n25.0\n\n\nβ_WAT_rsa\n6.0\n20.0\n\n\nα_NUT_rsa05\n0.7\n0.9999\n\n\nα_NUT_amc05\n0.7\n0.9999\n\n\nδ_NUT_rsa\n0.1\n25.0\n\n\nδ_NUT_amc\n0.1\n15.0\n\n\nβ_NUT_rsa\n6.0\n20.0\n\n\nβ_NUT_amc\n6.0\n20.0\n\n\nα_NUT_TSB\n5000.0\n25000.0\n\n\nκ_ROOT_rsa\n0.0\n0.4\n\n\nκ_ROOT_amc\n0.0\n0.4\n\n\nζ_SEAmin\n0.3\n1.0\n\n\nζ_SEAmax\n1.0\n3.0\n\n\nζ_SEA_ST1\n500.0\n800.0\n\n\nζ_SEA_ST2\n1200.0\n1800.0\n\n\nα_SEN_month\n0.03\n0.1\n\n\nβ_SEN_sla\n0.0\n3.0\n\n\nψ_SEN_ST1\n700.0\n2000.0\n\n\nψ_SENmax\n1.0\n3.0\n\n\nβ_GRZ_lnc\n0.0\n3.0\n\n\nβ_GRZ_H\n0.0\n3.0",
    "crumbs": [
      "Parameter",
      "Optimized parameter"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Calibration of the process-based model GrasslandTraitSim.jl v1",
    "section": "",
    "text": "This websites shows the calibration of the GrasslandTraitSim.jl grassland simulation model.\nThe main model descrition can be found in the GrasslandTraitSim.jl documentation.\nThe Julia programming code of the model can be found on github.com/FelixNoessler/GrasslandTraitSim.jl.\nThe Julia scripts for doing the calibration can be found on github.com/FelixNoessler/calibration_grasslandtraitsim_v1."
  },
  {
    "objectID": "calibration_results_sites.html",
    "href": "calibration_results_sites.html",
    "title": "Calibration results",
    "section": "",
    "text": "For all calibration and validation sites, the observed data (black dots) and the simulation output (red and grey lines) are visualised. The red line represents the best and the grey lines the 25 best parameter combinations from the population.\n\nCalibration sitesValidation sites\n\n\n\n    \n    Select a site\n    \n    \n\n    05\n    06\n    10\n    11\n    13\n    14\n    26\n    28\n    29\n    34\n    47\n    48\n    49\n    50\n\n\n\n\n\n\n\n\n    \n    Select a site\n    \n\n\n    01\n    02\n    03\n    04\n    15\n    22\n    23\n    24\n    27\n    30\n    31\n    32\n    33\n    37",
    "crumbs": [
      "Calibration results",
      "Sites"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html",
    "href": "calibration_results_patterns.html",
    "title": "Patterns in the model",
    "section": "",
    "text": "We will use the first (HEG01: mostly used as meadow) and the seventh grassland site (HEG07 mostly used as pasture) from the Hainich exploratories. If it is not indicated which site was used, the first site is used. We only simulate one species for now. We will use the mean trait values for the species. We will load the optimized parameters for the model. For the influence of traits, we will simulate two species with the same mean trait values, but one species will have a lower or higher value for the trait we want to investigate.\nWe will change the following conditions:\n\nManagement: mowing, grazing\nClimate: precipitation, potential evapotranspiration, temperature, photosynthetically active radiation\nSite conditions: grain size distribution, bulk density, organic matter content\nTraits: specific leaf area, arbuscular mycorrhizal colonization, potential height, root surface area per belowground biomass, aboveground biomass proportion, leaf nitrogen content per leaf biomass\n\nto debug the code and check for patterns in the model.\n\n\nCode\nimport GrasslandTraitSim as sim\nusing CairoMakie\nusing Statistics\nusing Accessors\nusing Unitful\n\n####################################### Run one simulation\nall_traits = sim.input_traits();\ninput_mowing_site = sim.validation_input(; plotID = \"HEG01\", nspecies = 1, time_step_days = 1);\ninput_grazing_site = sim.validation_input(; plotID = \"HEG07\", nspecies = 1, time_step_days = 1);\ntrait_input = (; zip(keys(all_traits), [mean(all_traits[t]) for t in keys(all_traits)])...)\np = sim.optim_parameter()\n\nsol_mowing = sim.solve_prob(; input_obj = input_mowing_site, p, trait_input);\nsol_grazing = sim.solve_prob(; input_obj = input_grazing_site, p, trait_input);\n\ninput_mowing_twospecies = sim.validation_input(; plotID = \"HEG01\", nspecies = 2, time_step_days = 1);\ninput_grazing_twospecies = sim.validation_input(; plotID = \"HEG07\", nspecies = 2, time_step_days = 1);\nx = sol_mowing.simp.output_date_num;\n\nfunction plot_difference(solsmowing, solsgrazing, variable::Symbol, legend_labels::Vector{String})\n    ylabel = Dict(:biomass =&gt; \"Total biomass [kg ha⁻¹]\", :above_biomass =&gt; \"Aboveground biomass [kg ha⁻¹]\",\n                  :below_biomass =&gt; \"Belowground biomass [kg ha⁻¹]\", :height =&gt; \"Plant height [m]\") \n\n    fig = Figure(; size = (500, 600))\n    ax1 = Axis(fig[1,1]; title = \"meadow\")\n    for sol in solsmowing\n        lines!(ax1, x, vec(ustrip.(sol.output[variable][:, 1, 1, 1])))\n    end\n    \n    ax2 = Axis(fig[2,1]; title = \"pasture\")\n    for (sol, label) in zip(solsgrazing, legend_labels)\n        lines!(ax2, x, vec(ustrip.(sol.output[variable][:, 1, 1, 1])), label = label)\n    end\n    \n    Label(fig[1:2, 0], ylabel[variable], rotation = pi/2)\n    Label(fig[3, 1], \"Time [year]\", tellwidth = false)\n    Legend(fig[4, 1], ax2; tellwidth = false, tellheight = true)\n    rowgap!(fig.layout, 2, 5)\n    rowgap!(fig.layout, 3, 15)\n    linkaxes!(ax1, ax2)\n    \n    fig\nend\n\nfunction plot_difference_one_site(sols, variable::Symbol, legend_labels::Vector{String}; title = \"meadow\")\n    ylabel = Dict(:biomass =&gt; \"Total biomass [kg ha⁻¹]\", :above_biomass =&gt; \"Aboveground biomass [kg ha⁻¹]\",\n                  :below_biomass =&gt; \"Belowground biomass [kg ha⁻¹]\", :height =&gt; \"Plant height [m]\") \n\n    fig = Figure(; size = (500, 500))\n    ax1 = Axis(fig[1,1]; title)\n    for (label, sol) in zip(legend_labels,sols)\n        lines!(ax1, x, vec(ustrip.(sol.output[variable][:, 1, 1, 1])), label = label)\n    end\n    \n    Label(fig[1, 0], ylabel[variable], rotation = pi/2, tellheight = false)\n    Label(fig[2, 1], \"Time [year]\", tellwidth = false)\n    Legend(fig[3, 1], ax1; tellwidth = false, tellheight = true)\n    rowgap!(fig.layout, 2, 15)\n    \n    fig\nend\n\nfunction plot_trait_difference(solmowing, solgrazing, variable::Symbol, legend_label::String)\n    ylabel = Dict(:biomass =&gt; \"Total biomass [kg ha⁻¹]\", :above_biomass =&gt; \"Aboveground biomass [kg ha⁻¹]\",\n                  :below_biomass =&gt; \"Belowground biomass [kg ha⁻¹]\", :height =&gt; \"Plant height [m]\") \n\n    fig = Figure(; size = (500, 600))\n    ax1, _ = lines(fig[1, 1], x, vec(ustrip.(solmowing.output[variable][:, 1, 1, 1])), \n          axis = (; title = \"meadow\"))\n    lines!(x, vec(ustrip.(solmowing.output[variable][:, 1, 1, 2])))\n    \n    ax2, _ = lines(fig[2, 1], x, vec(ustrip.(solgrazing.output[variable][:, 1, 1, 1])), label = \"reference\",\n          axis = (; title = \"pasture\"))\n    lines!(x, vec(ustrip.(solgrazing.output[variable][:, 1, 1, 2])), label = legend_label)\n    \n    Label(fig[1:2, 0], ylabel[variable], rotation = pi/2)\n    Label(fig[3, 1], \"Time [year]\", tellwidth = false)\n    Legend(fig[4, 1], ax2; tellwidth = false, tellheight = true)\n    rowgap!(fig.layout, 2, 5)\n    rowgap!(fig.layout, 3, 15)\n    linkaxes!(ax1, ax2)\n    \n    fig\nend\n\nCairoMakie.update_theme!(; Axis = (; xticks = 2006:4:2022, \n                                   xminorticks = 2006:2022, \n                                   xminorticksvisible = true))",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#mowing",
    "href": "calibration_results_patterns.html#mowing",
    "title": "Patterns in the model",
    "section": "2.1 Mowing",
    "text": "2.1 Mowing\n\n\nCode\ninput_mowing_site_mod1 = deepcopy(input_mowing_site)\ninput_mowing_site_mod1.input.CUT_mowing .= NaN * u\"m\"\nsol_mowing_mod1 = sim.solve_prob(; input_obj = input_mowing_site_mod1, p, trait_input)\n\ninput_grazing_site_mod1 = deepcopy(input_grazing_site)\ninput_grazing_site_mod1.input.CUT_mowing .= NaN * u\"m\"\nsol_grazing_mod1 = sim.solve_prob(; input_obj = input_grazing_site_mod1, p, trait_input);\nmylabels = [\"reference\", \"no mowing\"];\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :above_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :below_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :height, mylabels)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#grazing",
    "href": "calibration_results_patterns.html#grazing",
    "title": "Patterns in the model",
    "section": "2.2 Grazing",
    "text": "2.2 Grazing\n\n\nCode\ninput_mowing_site_mod1 = deepcopy(input_mowing_site)\ninput_mowing_site_mod1.input.LD_grazing .= NaN / u\"ha\"\nsol_mowing_mod1 = sim.solve_prob(; input_obj = input_mowing_site_mod1, p, trait_input)\n\ninput_grazing_site_mod1 = deepcopy(input_grazing_site)\ninput_grazing_site_mod1.input.LD_grazing .= NaN / u\"ha\"\nsol_grazing_mod1 = sim.solve_prob(; input_obj = input_grazing_site_mod1, p, trait_input);\nmylabels = [\"reference\", \"no grazing\"];\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :above_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :below_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :height, mylabels)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#mowing-and-grazing",
    "href": "calibration_results_patterns.html#mowing-and-grazing",
    "title": "Patterns in the model",
    "section": "2.3 Mowing and Grazing",
    "text": "2.3 Mowing and Grazing\n\n\nCode\ninput_mowing_site_mod1 = deepcopy(input_mowing_site)\ninput_mowing_site_mod1.input.CUT_mowing .= NaN * u\"m\"\ninput_mowing_site_mod1.input.LD_grazing .= NaN / u\"ha\"\nsol_mowing_mod1 = sim.solve_prob(; input_obj = input_mowing_site_mod1, p, trait_input)\n\ninput_grazing_site_mod1 = deepcopy(input_grazing_site)\ninput_grazing_site_mod1.input.CUT_mowing .= NaN * u\"m\"\ninput_grazing_site_mod1.input.LD_grazing .= NaN / u\"ha\"\nsol_grazing_mod1 = sim.solve_prob(; input_obj = input_grazing_site_mod1, p, trait_input);\nmylabels = [\"reference\", \"no management\"];\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :above_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :below_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :height, mylabels)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#precipitation",
    "href": "calibration_results_patterns.html#precipitation",
    "title": "Patterns in the model",
    "section": "3.1 Precipitation",
    "text": "3.1 Precipitation\n\n\nCode\ninput_mowing_site_mod1 = deepcopy(input_mowing_site)\ninput_mowing_site_mod1.input.precipitation ./= 2\nsol_mowing_mod1 = sim.solve_prob(; input_obj = input_mowing_site_mod1, p, trait_input)\n\ninput_mowing_site_mod2 = deepcopy(input_mowing_site)\ninput_mowing_site_mod2.input.precipitation .= 0.0u\"mm\"\nsol_mowing_mod2 = sim.solve_prob(; input_obj = input_mowing_site_mod2, p, trait_input);\n\ninput_grazing_site_mod1 = deepcopy(input_grazing_site)\ninput_grazing_site_mod1.input.precipitation ./= 2\nsol_grazing_mod1 = sim.solve_prob(; input_obj = input_grazing_site_mod1, p, trait_input)\n\ninput_grazing_site_mod2 = deepcopy(input_grazing_site)\ninput_grazing_site_mod2.input.precipitation .= 0.0u\"mm\"\nsol_grazing_mod2 = sim.solve_prob(; input_obj = input_grazing_site_mod2, p, trait_input);\nmylabels = [\"reference\", \"precipitation / 2\", \"no precipitation\"];\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], [sol_grazing, sol_grazing_mod1, sol_grazing_mod2], :biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], [sol_grazing, sol_grazing_mod1, sol_grazing_mod2], :above_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], [sol_grazing, sol_grazing_mod1, sol_grazing_mod2], :below_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], [sol_grazing, sol_grazing_mod1, sol_grazing_mod2], :height, mylabels)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#potential-evapotranspiration",
    "href": "calibration_results_patterns.html#potential-evapotranspiration",
    "title": "Patterns in the model",
    "section": "3.2 Potential evapotranspiration",
    "text": "3.2 Potential evapotranspiration\n\n\nCode\ninput_mowing_site_mod1 = deepcopy(input_mowing_site)\ninput_mowing_site_mod1.input.PET_sum ./= 2\nsol_mowing_mod1 = sim.solve_prob(; input_obj = input_mowing_site_mod1, p, trait_input)\n\ninput_grazing_site_mod1 = deepcopy(input_grazing_site)\ninput_grazing_site_mod1.input.PET_sum ./= 2\nsol_grazing_mod1 = sim.solve_prob(; input_obj = input_grazing_site_mod1, p, trait_input);\nmylabels = [\"reference\", \"PET ⋅ 0.5\"];\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :above_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :below_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :height, mylabels)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#temperature",
    "href": "calibration_results_patterns.html#temperature",
    "title": "Patterns in the model",
    "section": "3.3 Temperature",
    "text": "3.3 Temperature\n\n\nCode\ninput_mowing_site_mod1 = deepcopy(input_mowing_site)\ninput_mowing_site_mod1.input.temperature .*= 0.5\nsol_mowing_mod1 = sim.solve_prob(; input_obj = input_mowing_site_mod1, p, trait_input)\n\ninput_grazing_site_mod1 = deepcopy(input_grazing_site)\ninput_grazing_site_mod1.input.temperature .*= 0.5\nsol_grazing_mod1 = sim.solve_prob(; input_obj = input_grazing_site_mod1, p, trait_input);\nmylabels = [\"reference\", \"T ⋅ 0.5\"];\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :above_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :below_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1], [sol_grazing, sol_grazing_mod1], :height, mylabels)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#photosynthetically-active-radiation",
    "href": "calibration_results_patterns.html#photosynthetically-active-radiation",
    "title": "Patterns in the model",
    "section": "3.4 Photosynthetically active radiation",
    "text": "3.4 Photosynthetically active radiation\n\n\nCode\ninput_mowing_site_mod1 = deepcopy(input_mowing_site)\ninput_mowing_site_mod1.input.PAR_sum .= round.(u\"MJ/ha\", input_mowing_site_mod1.input.PAR_sum .* 1.5)\nsol_mowing_mod1 = sim.solve_prob(; input_obj = input_mowing_site_mod1, p, trait_input)\n\ninput_mowing_site_mod2 = deepcopy(input_mowing_site)\ninput_mowing_site_mod2.input.PAR .= round.(u\"MJ/ha\", input_mowing_site_mod2.input.PAR .* 0.5)\nsol_mowing_mod2 = sim.solve_prob(; input_obj = input_mowing_site_mod2, p, trait_input);\n\ninput_grazing_site_mod1 = deepcopy(input_grazing_site)\ninput_grazing_site_mod1.input.PAR_sum .= round.(u\"MJ/ha\", input_grazing_site_mod1.input.PAR_sum .* 1.5)\nsol_grazing_mod1 = sim.solve_prob(; input_obj = input_grazing_site_mod1, p, trait_input)\n\ninput_grazing_site_mod2 = deepcopy(input_grazing_site)\ninput_grazing_site_mod2.input.PAR .= round.(u\"MJ/ha\", input_grazing_site_mod2.input.PAR .* 0.5)\nsol_grazing_mod2 = sim.solve_prob(; input_obj = input_grazing_site_mod2, p, trait_input);\nmylabels = [\"reference\", \"1.5 ⋅ PARsum (more growth)\", \"0.5 ⋅ PAR (less radiation damage)\"];\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], [sol_grazing, sol_grazing_mod1, sol_grazing_mod2], :biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], [sol_grazing, sol_grazing_mod1, sol_grazing_mod2], :above_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], [sol_grazing, sol_grazing_mod1, sol_grazing_mod2], :below_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], [sol_grazing, sol_grazing_mod1, sol_grazing_mod2], :height, mylabels)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#grain-size-distribution",
    "href": "calibration_results_patterns.html#grain-size-distribution",
    "title": "Patterns in the model",
    "section": "4.1 Grain size distribution",
    "text": "4.1 Grain size distribution\n\nuFC: usable field capacity\n\n\n\nCode\ninput_mowing_site_mod1 = deepcopy(input_mowing_site)\n@reset input_mowing_site_mod1.site.sand = input_mowing_site_mod1.site.sand + 0.5\n@reset input_mowing_site_mod1.site.clay = input_mowing_site_mod1.site.clay - 0.5\nsol_mowing_mod1 = sim.solve_prob(; input_obj = input_mowing_site_mod1, p, trait_input)\n\ninput_mowing_site_mod2 = deepcopy(input_mowing_site)\n@reset input_mowing_site_mod2.site.silt = input_mowing_site_mod2.site.silt - 0.4\n@reset input_mowing_site_mod2.site.clay = input_mowing_site_mod2.site.clay + 0.4\nsol_mowing_mod2 = sim.solve_prob(; input_obj = input_mowing_site_mod2, p, trait_input);\n\ninput_mowing_site_mod3 = deepcopy(input_mowing_site)\n@reset input_mowing_site_mod3.site.silt = input_mowing_site_mod3.site.silt + 0.4\n@reset input_mowing_site_mod3.site.clay = input_mowing_site_mod3.site.clay - 0.4\nsol_mowing_mod3 = sim.solve_prob(; input_obj = input_mowing_site_mod3, p, trait_input);\n\nuFC(sol) = round(u\"mm\", sol.patch_variables.WHC[1, 1]  - sol.patch_variables.PWP[1, 1]; digits = 0)\ngrain_size_str(sol) = \"sand: $(round(sol.site.sand; digits = 3)), silt: $(round(sol.site.silt; digits = 3)), \\nclay: $(round(sol.site.clay; digits = 3)), uFC: $(uFC(sol))\";\nmylabels = [\"$l; $(grain_size_str(s))\" for (l,s) in zip([\"reference\", \"more sand\", \"more clay\", \"more silt\"], [sol_mowing, sol_mowing_mod1, sol_mowing_mod2, sol_mowing_mod3])];\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_difference_one_site([sol_mowing, sol_mowing_mod1, sol_mowing_mod2, sol_mowing_mod3], :biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference_one_site([sol_mowing, sol_mowing_mod1, sol_mowing_mod2, sol_mowing_mod3], :above_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference_one_site([sol_mowing, sol_mowing_mod1, sol_mowing_mod2, sol_mowing_mod3], :below_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference_one_site([sol_mowing, sol_mowing_mod1, sol_mowing_mod2, sol_mowing_mod3], :height, mylabels)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#bulk-density-organic-matter-content",
    "href": "calibration_results_patterns.html#bulk-density-organic-matter-content",
    "title": "Patterns in the model",
    "section": "4.2 Bulk density, organic matter content",
    "text": "4.2 Bulk density, organic matter content\n\n\nCode\ninput_mowing_site_mod1 = deepcopy(input_mowing_site)\n@reset input_mowing_site_mod1.site.organic = input_mowing_site_mod1.site.organic * 1.5\nsol_mowing_mod1 = sim.solve_prob(; input_obj = input_mowing_site_mod1, p, trait_input)\n\ninput_mowing_site_mod2 = deepcopy(input_mowing_site)\n@reset input_mowing_site_mod2.site.bulk = input_mowing_site_mod2.site.bulk * 1.5\nsol_mowing_mod2 = sim.solve_prob(; input_obj = input_mowing_site_mod2, p, trait_input);\n\nbulk_organic(sol) = \"organic: $(round(sol.site.organic; digits = 3)), bulk: $(round(u\"g/cm^3\", sol.site.bulk; digits = 3)), \\n uFC: $(uFC(sol))\";\nmylabels = [\"$l; $(grain_size_str(s))\" for (l,s) in zip([\"reference\", \"higher organic matter content\", \"higher bulk density\"], [sol_mowing, sol_mowing_mod1, sol_mowing_mod2])];\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_difference_one_site([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], :biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference_one_site([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], :above_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference_one_site([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], :below_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference_one_site([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], :height, mylabels)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#nutrients",
    "href": "calibration_results_patterns.html#nutrients",
    "title": "Patterns in the model",
    "section": "4.3 Nutrients",
    "text": "4.3 Nutrients\n\n\nCode\ninput_mowing_site_mod1 = deepcopy(input_mowing_site)\n@reset input_mowing_site_mod1.site.totalN = input_mowing_site_mod1.site.totalN * 0.5\nsol_mowing_mod1 = sim.solve_prob(; input_obj = input_mowing_site_mod1, p, trait_input)\n\ninput_mowing_site_mod2 = deepcopy(input_mowing_site)\n@reset input_mowing_site_mod2.site.totalN = input_mowing_site_mod2.site.totalN * 1.5\nsol_mowing_mod2 = sim.solve_prob(; input_obj = input_mowing_site_mod2, p, trait_input);\nmylabels = [\"reference\", \"less nutrients (totalN ⋅ 0.5)\", \"more nutrients (totalN ⋅ 1.5)\"];\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_difference_one_site([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], :biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference_one_site([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], :above_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference_one_site([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], :below_biomass, mylabels)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_difference_one_site([sol_mowing, sol_mowing_mod1, sol_mowing_mod2], :height, mylabels)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#specific-leaf-area",
    "href": "calibration_results_patterns.html#specific-leaf-area",
    "title": "Patterns in the model",
    "section": "5.1 Specific leaf area",
    "text": "5.1 Specific leaf area\n\n\nCode\ntraits_twospecies = (; zip(keys(all_traits), [fill(mean(all_traits[t]), 2) for t in keys(all_traits)])...)\ntraits_twospecies.sla[2] = traits_twospecies.sla[2] * 0.8\ntraits_twospecies.amc[1] = traits_twospecies.amc[1] * 1.000000001\ntraits_twospecies.rsa[1] = traits_twospecies.rsa[1] * 1.00000001\n\nsol_mowing = sim.solve_prob(; input_obj = input_mowing_twospecies, p, trait_input = traits_twospecies)\nsol_grazing = sim.solve_prob(; input_obj = input_grazing_twospecies, p, trait_input = traits_twospecies);\nmylegendlabel = \"species with low sla (0.8 ⋅ sla)\";\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :above_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :below_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :height, mylegendlabel)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#arbuscular-mycorrhizal-colonization",
    "href": "calibration_results_patterns.html#arbuscular-mycorrhizal-colonization",
    "title": "Patterns in the model",
    "section": "5.2 Arbuscular mycorrhizal colonization",
    "text": "5.2 Arbuscular mycorrhizal colonization\n\n\nCode\ntraits_twospecies = (; zip(keys(all_traits), [fill(mean(all_traits[t]), 2) for t in keys(all_traits)])...)\ntraits_twospecies.amc[2] = traits_twospecies.amc[2] * 0.5\ntraits_twospecies.amc[1] = traits_twospecies.amc[1] * 1.000000001\ntraits_twospecies.rsa[1] = traits_twospecies.rsa[1] * 1.00000001\n\nsol_mowing = sim.solve_prob(; input_obj = input_mowing_twospecies, p, trait_input = traits_twospecies)\nsol_grazing = sim.solve_prob(; input_obj = input_grazing_twospecies, p, trait_input = traits_twospecies);\nmylegendlabel = \"species with low amc (0.5 ⋅ amc)\";\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :above_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :below_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :height, mylegendlabel)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#maximum-height",
    "href": "calibration_results_patterns.html#maximum-height",
    "title": "Patterns in the model",
    "section": "5.3 Maximum height",
    "text": "5.3 Maximum height\n\n\nCode\ntraits_twospecies = (; zip(keys(all_traits), [fill(mean(all_traits[t]), 2) for t in keys(all_traits)])...)\ntraits_twospecies.maxheight[2] = traits_twospecies.maxheight[2] * 0.5\ntraits_twospecies.amc[1] = traits_twospecies.amc[1] * 1.000000001\ntraits_twospecies.rsa[1] = traits_twospecies.rsa[1] * 1.00000001\n\nsol_mowing = sim.solve_prob(; input_obj = input_mowing_twospecies, p, trait_input = traits_twospecies)\nsol_grazing = sim.solve_prob(; input_obj = input_grazing_twospecies, p, trait_input = traits_twospecies);\nmylegendlabel = \"species with low maxheight (0.5 ⋅ maxheight)\";\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :above_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :below_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :height, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\n5.3.1 Maximum height without mowing\n\n\nCode\ntraits_twospecies = (; zip(keys(all_traits), [fill(mean(all_traits[t]), 2) for t in keys(all_traits)])...)\ntraits_twospecies.maxheight[2] = traits_twospecies.maxheight[2] * 0.5\ntraits_twospecies.amc[1] = traits_twospecies.amc[1] * 1.000000001\ntraits_twospecies.rsa[1] = traits_twospecies.rsa[1] * 1.00000001\n\ninput_grazing_twospecies_mod = deepcopy(input_grazing_twospecies)\ninput_mowing_twospecies_mod = deepcopy(input_mowing_twospecies)\n@reset input_grazing_twospecies_mod.simp.included.mowing = false\n@reset input_mowing_twospecies_mod.simp.included.mowing = false\n\nsol_mowing = sim.solve_prob(; input_obj = input_mowing_twospecies_mod, p, trait_input = traits_twospecies)\nsol_grazing = sim.solve_prob(; input_obj = input_grazing_twospecies_mod, p, trait_input = traits_twospecies);\nmylegendlabel = \"species with low maxheight (0.5 ⋅ maxheight)\";\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :above_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :below_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :height, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5.3.2 Maximum height without grazing\n\n\nCode\ntraits_twospecies = (; zip(keys(all_traits), [fill(mean(all_traits[t]), 2) for t in keys(all_traits)])...)\ntraits_twospecies.maxheight[2] = traits_twospecies.maxheight[2] * 0.5\ntraits_twospecies.amc[1] = traits_twospecies.amc[1] * 1.000000001\ntraits_twospecies.rsa[1] = traits_twospecies.rsa[1] * 1.00000001\n\ninput_grazing_twospecies_mod = deepcopy(input_grazing_twospecies)\ninput_mowing_twospecies_mod = deepcopy(input_mowing_twospecies)\n@reset input_grazing_twospecies_mod.simp.included.grazing = false\n@reset input_mowing_twospecies_mod.simp.included.grazing = false\n\nsol_mowing = sim.solve_prob(; input_obj = input_mowing_twospecies_mod, p, trait_input = traits_twospecies)\nsol_grazing = sim.solve_prob(; input_obj = input_grazing_twospecies_mod, p, trait_input = traits_twospecies);\nmylegendlabel = \"species with low maxheight (0.5 ⋅ maxheight)\";\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :above_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :below_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :height, mylegendlabel)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#root-surface-area-per-belowground-biomass",
    "href": "calibration_results_patterns.html#root-surface-area-per-belowground-biomass",
    "title": "Patterns in the model",
    "section": "5.4 Root surface area per belowground biomass",
    "text": "5.4 Root surface area per belowground biomass\n\n\nCode\ntraits_twospecies = (; zip(keys(all_traits), [fill(mean(all_traits[t]), 2) for t in keys(all_traits)])...)\ntraits_twospecies.rsa[2] = traits_twospecies.rsa[2] * 0.5\ntraits_twospecies.amc[1] = traits_twospecies.amc[1] * 1.000000001\ntraits_twospecies.rsa[1] = traits_twospecies.rsa[1] * 1.00000001\n\nsol_mowing = sim.solve_prob(; input_obj = input_mowing_twospecies, p, trait_input = traits_twospecies)\nsol_grazing = sim.solve_prob(; input_obj = input_grazing_twospecies, p, trait_input = traits_twospecies);\nmylegendlabel = \"species with low RSA (0.5 ⋅ RSA)\";\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :above_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :below_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :height, mylegendlabel)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#aboveground-biomass-proportion",
    "href": "calibration_results_patterns.html#aboveground-biomass-proportion",
    "title": "Patterns in the model",
    "section": "5.5 Aboveground biomass proportion",
    "text": "5.5 Aboveground biomass proportion\n\n\nCode\ntraits_twospecies = (; zip(keys(all_traits), [fill(mean(all_traits[t]), 2) for t in keys(all_traits)])...)\ntraits_twospecies.abp[2] = traits_twospecies.abp[2] * 0.5\ntraits_twospecies.lbp[2] = traits_twospecies.abp[2] * 0.8 ## lbp has to be updated\ntraits_twospecies.amc[1] = traits_twospecies.amc[1] * 1.000000001\ntraits_twospecies.rsa[1] = traits_twospecies.rsa[1] * 1.00000001\n\nsol_mowing = sim.solve_prob(; input_obj = input_mowing_twospecies, p, trait_input = traits_twospecies)\nsol_grazing = sim.solve_prob(; input_obj = input_grazing_twospecies, p, trait_input = traits_twospecies);\nmylegendlabel = \"species with low ABP (0.5 ⋅ ABP)\";\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :above_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :below_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :height, mylegendlabel)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_results_patterns.html#leaf-nitrogen-content-per-leaf-biomass",
    "href": "calibration_results_patterns.html#leaf-nitrogen-content-per-leaf-biomass",
    "title": "Patterns in the model",
    "section": "5.6 Leaf nitrogen content per leaf biomass",
    "text": "5.6 Leaf nitrogen content per leaf biomass\n\n\nCode\ntraits_twospecies = (; zip(keys(all_traits), [fill(mean(all_traits[t]), 2) for t in keys(all_traits)])...)\ntraits_twospecies.lnc[2] = traits_twospecies.lnc[2] * 0.5\ntraits_twospecies.amc[1] = traits_twospecies.amc[1] * 1.000000001\ntraits_twospecies.rsa[1] = traits_twospecies.rsa[1] * 1.00000001\n\nsol_mowing = sim.solve_prob(; input_obj = input_mowing_twospecies, p, trait_input = traits_twospecies)\nsol_grazing = sim.solve_prob(; input_obj = input_grazing_twospecies, p, trait_input = traits_twospecies)\nmylegendlabel = \"species with low LNC (0.5 ⋅ LNC)\";\n\n\n\nTotal biomassAboveground biomassBelowground biomassHeight\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :above_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :below_biomass, mylegendlabel)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot_trait_difference(sol_mowing, sol_grazing, :height, mylegendlabel)",
    "crumbs": [
      "Calibration results",
      "Patterns"
    ]
  },
  {
    "objectID": "calibration_details.html",
    "href": "calibration_details.html",
    "title": "Technical details on the calibration",
    "section": "",
    "text": "We use multiobjective optimization to calibrate the parameters. The objectives are:\n\ncut aboveground biomass\ncommunity weighted mean trais (specific leaf area, maximum height, )\n\nWe use NSGA-II: Non-dominated Sorting Genetic Algorithm Deb et al. (2002) as implemented in Metaheuristics.jl Mejía-de-Dios and Mezura-Montes (2022).\nWe weight the objectives 50 % to aboveground biomass and 50 % distributed equally among the community weighted mean traits.\n\n\n\n\n\n\nCalibration script\n\n\n\n\n\nThe calibration was done using the following script:\nimport GrasslandTraitSim as sim\n\nusing Accessors\nusing Unitful\nusing UnPack\nusing Metaheuristics\nusing DimensionalData\nusing Statistics\nusing CairoMakie\nusing Distributions\nusing JMcDM\nimport Dates\nusing PairPlots\nusing PrettyTables\nusing DataFrames\nusing JLD2\n\nincludet(\"0_error_functions.jl\")\nincludet(\"0_calibration_object.jl\")\nincludet(\"0_logger_plots.jl\")\n\nfunction run_optimization(opt_obj, function_calls = 200, time_limit_seconds = Inf;\n                          X0 = nothing, tmp_location = \"\")\n    bounds = BoxConstrainedSpace(lb = opt_obj.lb, ub = opt_obj.ub)\n    options = Options(f_calls_limit = function_calls,\n                      time_limit = float(time_limit_seconds),\n                      parallel_evaluation = true,\n                      store_convergence = true,\n                      verbose = true,\n                      iterations = 5000);\n\n    function f(x)\n        fx = total_error(opt_obj, x)\n        return fx, [0.0], [0.0]\n    end\n\n    function f_parallel(X)\n        N = size(X,1)\n        nobjectives = 7\n        fx, gx, hx = zeros(N,nobjectives), zeros(N,1), zeros(N,1)\n        Threads.@threads for i in 1:N\n            fx[i,:], gx[i,:], hx[i,:] = f(X[i,:])\n        end\n        fx, gx, hx\n    end\n\n    algo = NSGA2(; options, N = 10 * length(opt_obj.lb))\n    if !isnothing(X0)\n        set_user_solutions!(algo, X0, f);\n    end\n\n    logger(st) = begin\n        if iszero(st.iteration % 5)\n            p = solution(st, opt_obj)\n            print(p)\n            iteration_str = lpad(st.iteration, 4, \"0\")\n            calibration_logplot(p, opt_obj, [:HEG05, :HEG06], tmp_location,\n                                iteration = iteration_str)\n            standing_biomass_mowing(p, opt_obj, :HEG05, tmp_location; iteration = iteration_str)\n            jldsave(\"$tmp_location/opt_$iteration_str.jld2\"; opt=st)\n        end\n    end\n\n    optimize(f_parallel, bounds, Restart(algo, every=200); logger)\nend\n\nout_dir = \"calibration_results/test\"\nmkpath(out_dir)\nmkpath(\"$out_dir/calibration_tmp\")\n\nbe_opt = BE_optimization(;);\n@info \"Start with the calibration\"\nopt = run_optimization(be_opt, 1.0e20, 10 * 60;\n                       tmp_location = \"$out_dir/calibration_tmp\")\n\njldsave(\"$out_dir/opt.jld2\"; opt)\n@info \"Saved optimization in $out_dir\"\n\n\n\n\n\n\n\n\n\nValidation script\n\n\n\n\n\nThe script for creating all graphics:\nimport GrasslandTraitSim as sim\nusing Accessors\nusing Unitful\nusing UnPack\nusing Metaheuristics\nusing DimensionalData\nusing Statistics\nusing CairoMakie\nusing JMcDM\nimport Dates\nusing PrettyTables\nusing DataFrames\nusing JLD2\n\nincludet(\"0_plot_functions.jl\")\nincludet(\"0_error_functions.jl\")\nincludet(\"0_calibration_object.jl\")\nincludet(\"validation_paper_figure.jl\")\n\n\nbe_valid = BE_optimization(all_sites = true)\n\nout_dir = \"calibration_results/\"\nwebsite_img_dir = \"docs/img\"\nopt = load(\"$out_dir/opt.jld2\")[\"opt\"];\n\n### weighting objectives\nws = fill(0.5 / 6, 7)\nws[1] = 0.5\nmy_dm = mcdm(opt, ws, TopsisMethod());\np_optimized = prepare_p(opt.population[my_dm.bestIndex].x, be_valid.parameter_names)\np = solution(opt, be_valid)\n\n## should be true\nall(be_valid.parameter_names .== String.(collect(keys(p_optimized))))\n\n### write to file: fixed parameter\nopen(\"$out_dir/0_optimized_parameter.txt\", \"w\") do f\n    pretty_table(f, [be_valid.parameter_names be_valid.lb  collect(p_optimized) be_valid.ub];\n        header = [\"Parameter\", \"Lower bound\",  \"optimized value\", \"Upper bound\"])\nend\n\n### write to file: fixed parameter\nopen(\"$out_dir/0_fixed_parameter.txt\", \"w\") do f\n    pretty_table(f, [String.(collect(keys(be_valid.fixed_parameter))) collect(be_valid.fixed_parameter)];\n                 header = [\"Parameter\", \"Value\"])\nend\n\n### update calibrated parameters for GrasslandTraitSim.jl package\nθ = prepare_p(opt.population[my_dm.bestIndex].x, be_valid.parameter_names)\njldsave(sim.assetpath(\"data/optim.jld2\"); θ)\n\n### plot the validation with the worst and best score for cut aboveground biomass\ndiff_sites = error_for_sites(be_valid, opt.population[my_dm.bestIndex].x;\n                             calc_all_sites = true)\nntrain = length(be_valid.BE_IDs_train)\nbiomass_diff_test = diff_sites[ntrain+1:end, 1]\nbest_site = be_valid.BE_IDs_test[sortperm(biomass_diff_test)[1]]\nworst_site = be_valid.BE_IDs_test[sortperm(biomass_diff_test)[end]]\nplot_two_site_paper(p, be_valid, [Symbol(best_site), Symbol(worst_site)], out_dir)\n\n### plot the best n parameters of the population with colour according to the score\n### that takes into account the weights of the objectives\n## the images will be visible on the website\nlet\n    selected_opt = opt\n    pos = positions(selected_opt)\n    my_dm = mcdm(selected_opt, ws, TopsisMethod());\n    scores = float.(my_dm.scores)\n    scores_sort = sortperm(scores, rev = true)\n    scores = scores[scores_sort]\n    pos = pos[scores_sort, :]\n    ncombinations = 25\n\n    for p in Symbol.(be_valid.BE_IDs)\n        @info \"Plotting site $(p)\"\n\n        f = plot_one_site_several_p(pos[1:ncombinations, :], scores[1:ncombinations],\n            be_valid, p)\n        save(\"$website_img_dir/calibration/$(p).png\", f)\n    end\nend\n\n\n\n\n\n\n\nReferences\n\nDeb, K., A. Pratap, S. Agarwal, and T. Meyarivan. 2002. “A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II.” IEEE Transactions on Evolutionary Computation 6 (2): 182–97. https://doi.org/10.1109/4235.996017.\n\n\nMejía-de-Dios, Jesús-Adolfo, and Efrén Mezura-Montes. 2022. “Metaheuristics: A Julia Package for Single- and Multi-Objective Optimization.” Journal of Open Source Software 7 (78): 4723. https://doi.org/10.21105/joss.04723.",
    "crumbs": [
      "Technical details on the calibration"
    ]
  },
  {
    "objectID": "calibration_results_overview.html",
    "href": "calibration_results_overview.html",
    "title": "Calibration results - Overview",
    "section": "",
    "text": "Code\nimport GrasslandTraitSim as sim\nusing Accessors\nusing Unitful\nusing DimensionalData\nusing UnPack\nusing Metaheuristics\nusing Statistics\nusing CairoMakie\nusing JMcDM\nimport Dates\nusing PairPlots\nusing DataFrames\nusing JLD2\n\ninclude(\"scripts/calibration/0_error_functions.jl\")\ninclude(\"scripts/calibration/0_calibration_object.jl\")\n\nbe_valid = BE_optimization(all_sites = true)\n\nout_dir = \"calibration_results/\"\nwebsite_img_dir = \"docs/img\"\nopt = load(\"$out_dir/opt.jld2\")[\"opt\"];\n\n### weighting objectives\nws = fill(0.5 / 6, 7)\nws[1] = 0.5\nmy_dm = mcdm(opt, ws, TopsisMethod());\np_optimized = prepare_p(opt.population[my_dm.bestIndex].x, be_valid.parameter_names)\n\n### calculate the mean absolute error for each site\ndiff_sites = error_for_sites(be_valid, opt.population[my_dm.bestIndex].x;\n                             calc_all_sites = true)\n\nset_theme!(fontsize = 18,\n    Axis = (xgridvisible = false, ygridvisible = false,\n        topspinevisible = false, rightspinevisible = false));",
    "crumbs": [
      "Calibration results",
      "Overview"
    ]
  },
  {
    "objectID": "calibration_results_overview.html#calibration-vs-validation-error",
    "href": "calibration_results_overview.html#calibration-vs-validation-error",
    "title": "Calibration results - Overview",
    "section": "1 Calibration vs validation error",
    "text": "1 Calibration vs validation error\n\n\nCode\nlet\n    objective_labels = [\n        \"Cut biomass\\n[kg ha⁻¹]\",\n        \"Root surface area\\nper belowground\\nbiomass [m² g⁻¹]\",\n        \"Aboveground\\nbiomass per\\ntotal biomass [-]\",\n        \"Specific leaf\\narea [m² g⁻¹]\",\n        \"Maximum\\nheight [m]\",\n        \"Arbuscular\\nmycorrhizal\\ncolonisation [-]\",\n        \"Leaf nitrogen per\\nleaf mass [mg g⁻¹]\"\n    ]\n    \n    nsites, nobjectives = size(diff_sites)\n    all_ids = vcat(be_valid.BE_IDs_train, be_valid.BE_IDs_test)\n\n    ntrain_sites = length(be_valid.BE_IDs_train)\n    trainings_loss = mean(diff_sites[1:ntrain_sites, :], dims = 1)\n    validation_loss = mean(diff_sites[ntrain_sites+1:end, :], dims = 1)\n\n    color_map = cgrad(:viridis, 3, categorical = true)\n    color_vals = fill(color_map[2], nsites)\n    color_vals[1:ntrain_sites] .= color_map[1]\n\n    title_label = rich(rich(\"Calibration\", color = color_map[1]),\n                       \" vs. \",\n                       rich(\"validation\", color = color_map[2]),\n                       \"\\nmean absolute error\")\n\n    fig = Figure()\n\n    for i in 1:nobjectives\n        Axis(fig[i, 1]; width = 400, height = 150, ylabel = String(objective_labels[i]),\n             xticks = (vcat(1:ntrain_sites, ntrain_sites+2:nsites+1), all_ids),\n             title = i == 1 ? title_label : \"\",\n             xlabel = i == nobjectives ? \"Site ID\" : \"\",\n             xticklabelsvisible = i == nobjectives ? true : false,\n             xticklabelrotation= pi/2,\n             xticklabelsize = 12)\n\n        scatter!(vcat(1:ntrain_sites, ntrain_sites+2:nsites+1), diff_sites[:, i]; color = color_vals, markersize = 8)\n        \n        \n        lines!([1, ntrain_sites], [trainings_loss[i], trainings_loss[i]],\n               color = color_map[1])\n        lines!([ntrain_sites+2, nsites+1], [validation_loss[i], validation_loss[i]],\n               color = color_map[2])\n    end\n    \n    [rowgap!(fig.layout, i, 0) for i in 1:6]\n\n    resize_to_layout!(fig)\n    fig\nend",
    "crumbs": [
      "Calibration results",
      "Overview"
    ]
  },
  {
    "objectID": "calibration_results_overview.html#trade-offs-in-the-objectives",
    "href": "calibration_results_overview.html#trade-offs-in-the-objectives",
    "title": "Calibration results - Overview",
    "section": "2 Trade-offs in the objectives",
    "text": "2 Trade-offs in the objectives\n\n2.1 Error in sites\n\n\nCode\npairplot(diff_sites =&gt; (\n    PairPlots.Scatter(markersize = 10),\n    PairPlots.MarginHist(),\n    PairPlots.MarginConfidenceLimits(),\n    PairPlots.TrendLine(color=:red), # default is red\n    PairPlots.Correlation());\n    labels = Dict(\n        Symbol(1) =&gt; \"cut biomass\",\n        Symbol(2) =&gt; \"rsa\",\n        Symbol(3) =&gt; \"abp\",\n        Symbol(4) =&gt; \"sla\",\n        Symbol(5) =&gt; \"maxheight\",\n        Symbol(6) =&gt; \"amc\",\n        Symbol(7) =&gt; \"lnc\"\n    ))\n\n\n\n\n\n\n\n\n\n\n\n2.2 Pareto front\n\n\nCode\nlet\n    objective_labels = [\"cut biomass\", \"rsa\", \"amc\", \"abp\", \"sla\", \"maxheight\", \"lnc\"]\n    df = DataFrame(pareto_front(opt), \n                   objective_labels)\n    pairplot(df =&gt; (PairPlots.Scatter(; markersize = 10, color = float.(my_dm.scores)),))\n    # dark lila is low, yellow is high\nend",
    "crumbs": [
      "Calibration results",
      "Overview"
    ]
  },
  {
    "objectID": "calibration_results_overview.html#parameter-values-in-the-population",
    "href": "calibration_results_overview.html#parameter-values-in-the-population",
    "title": "Calibration results - Overview",
    "section": "3 Parameter values in the population",
    "text": "3 Parameter values in the population\n\n\nCode\nlet\n    pos = positions(opt)\n    p_names = be_valid.parameter_names\n\n    fig = Figure()\n    axes = []\n    for i in eachindex(p_names)\n        ax = Axis(fig[i, 1]; width = 400, height = 80)\n        hist!(pos[:, i], bins = 20)\n        Label(fig[i, 1], p_names[i], halign = :center, valign = :top)\n        push!(axes, ax)\n    end\n    \n    resize_to_layout!(fig)  \n    linkyaxes!(axes...)  \n    fig\nend\n\n\n\n\n\n\n\n\n\n\n3.1 Parameter values vs objective scores\n\nthe horizontal red lines are the selected parameter values\n\n\n\nCode\nlet\n    # Parameter values vs objective functions\n    objective_labels = [\"cut biomass\", :rsa, :amc, :abp, :sla, :maxheight, :lnc]\n    nparameter = length(be_valid.parameter_names)\n    nobjectives = length(objective_labels)\n\n    f_values = fvals(opt)\n    pos = positions(opt)\n    x = opt.population[my_dm.bestIndex].x\n\n    fig = Figure()\n    for i in 1:nobjectives\n        for u in 1:nparameter\n            Axis(fig[u, i],\n                 xlabel = u == nparameter ? String(objective_labels[i]) : \"\",\n                 ylabel = i == 1 ? be_valid.parameter_names[u] : \"\",\n                 yticklabelsvisible = i == 1 ? true : false,\n                 xticklabelsvisible = u == nparameter ? true : false,\n                 width = 200, height = 150)\n            scatter!(f_values[:, i], pos[:, u], color = float.(my_dm.scores))\n            hlines!(x[u]; color = :red, linewidth = 2)\n        end\n    end\n\n    resize_to_layout!(fig)\n    # dark lila is low, yellow is high\n    fig\nend",
    "crumbs": [
      "Calibration results",
      "Overview"
    ]
  },
  {
    "objectID": "calibration_results_scenario.html",
    "href": "calibration_results_scenario.html",
    "title": "Scenario analysis",
    "section": "",
    "text": "Select a site\n    \n\n\n    05\n    06\n    10\n    11\n    13\n    14\n    26\n    28\n    29\n    34\n    47\n    48\n    49\n    50\n    01\n    02\n    03\n    04\n    15\n    22\n    23\n    24\n    27\n    30\n    31\n    32\n    33\n    37",
    "crumbs": [
      "Calibration results",
      "Scenario analysis"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "Data of the Biodiversity Exploratories",
    "section": "",
    "text": "The data from the Biodiversity Exploraties can be downloaded from the BExIS data base. Also the metadata for all datasets is available there.\n\n\n\n\n\n\nScript for downloading all data sets from BExIS\n\n\n\n\n\nThe following R-script downloads all data sets from the Biodiversity Exploratories data base:\n\n\ndownload_bexis.R\n\n# install with:\n# devtools::install_github(\"BEXIS2/rBExIS\", subdir = \"rBExIS\")\nlibrary(rBExIS) \nlibrary(readr)\n\ndownload_bexis_dataset &lt;- function(id, name, output_dir){\n    dir.create(\"data/\", showWarnings = FALSE)\n    api_url &lt;- rBExIS:::get_api_url(\"/data/\")\n    table_data &lt;- content(rBExIS:::get_response(\"GET\", paste0(api_url, id)))\n    write_csv(table_data, paste0(output_dir, name, \".csv\"))\n}\n\nbexis.options(\"base_url\" = \"https://www.bexis.uni-jena.de/\")\ndata_dir = \"data/\"\n\n\n## approximate (public) coordinates \ndownload_bexis_dataset(id = 1000, name = \"approx_site_coordinates\", output_dir = data_dir)\n \n## management input for grazing and mowing\ndownload_bexis_dataset(id = 31715, name = \"management_input\", output_dir = data_dir)\ndownload_bexis_dataset(id = 25086, name = \"LUI_tool_input\", output_dir = data_dir)\n\n## cut biomass (botany core)\ndownload_bexis_dataset(id = 16209, name = \"biomass_2009\", output_dir = data_dir)\ndownload_bexis_dataset(id = 12706, name = \"biomass_2010\", output_dir = data_dir)\ndownload_bexis_dataset(id = 14346, name = \"biomass_2011\", output_dir = data_dir)\n\n## cut biomass (sade)\ndownload_bexis_dataset(id = 19812, name = \"biomass_2015_sade\", output_dir = data_dir)\ndownload_bexis_dataset(id = 23506, name = \"biomass_2017_sade\", output_dir = data_dir)\n\n## cut biomass (hedge II)\ndownload_bexis_dataset(id = 31138, name = \"biomass_2017_hainich_hedgeII\", output_dir = data_dir)\ndownload_bexis_dataset(id = 31139, name = \"biomass_2018_alb_hedgeII\", output_dir = data_dir)\n\n## vegetation\ndownload_bexis_dataset(id = 31389, name = \"vegetation_2008_2022\", output_dir = data_dir)\n\n## vegetation header data\ndownload_bexis_dataset(id = 6340, name = \"vegetation_header_data_2009\", output_dir = data_dir)\ndownload_bexis_dataset(id = 13486, name = \"vegetation_header_data_2010\", output_dir = data_dir)\ndownload_bexis_dataset(id = 14326, name = \"vegetation_header_data_2011\", output_dir = data_dir)\ndownload_bexis_dataset(id = 15588, name = \"vegetation_header_data_2012\", output_dir = data_dir)\ndownload_bexis_dataset(id = 16826, name = \"vegetation_header_data_2013\", output_dir = data_dir)\ndownload_bexis_dataset(id = 19807, name = \"vegetation_header_data_2014\", output_dir = data_dir)\ndownload_bexis_dataset(id = 19809, name = \"vegetation_header_data_2015\", output_dir = data_dir)\ndownload_bexis_dataset(id = 21187, name = \"vegetation_header_data_2016\", output_dir = data_dir)\ndownload_bexis_dataset(id = 31466, name = \"vegetation_header_data_2017\", output_dir = data_dir)\ndownload_bexis_dataset(id = 24166, name = \"vegetation_header_data_2018\", output_dir = data_dir)\ndownload_bexis_dataset(id = 26151, name = \"vegetation_header_data_2019\", output_dir = data_dir)\ndownload_bexis_dataset(id = 27426, name = \"vegetation_header_data_2020\", output_dir = data_dir)\ndownload_bexis_dataset(id = 31180, name = \"vegetation_header_data_2021\", output_dir = data_dir)\ndownload_bexis_dataset(id = 31387, name = \"vegetation_header_data_2022\", output_dir = data_dir)\n\n## leaf traits\ndownload_bexis_dataset(id = 24807, name = \"leaf_traits\", output_dir = data_dir)\n\n## root traits\ndownload_bexis_dataset(id = 26546, name = \"root_traits\", output_dir = data_dir)\n\n## soil nutrients\ndownload_bexis_dataset(id = 14446, name = \"soilnutrients_2011\", output_dir = data_dir)\ndownload_bexis_dataset(id = 18787, name = \"soilnutrients_2014\", output_dir = data_dir)\ndownload_bexis_dataset(id = 23846, name = \"soilnutrients_2017\", output_dir = data_dir)\ndownload_bexis_dataset(id = 31210, name = \"soilnutrients_2021\", output_dir = data_dir)\n\n## soil texture\ndownload_bexis_dataset(id = 14686, name = \"soiltexture_2011\", output_dir = data_dir)\n\n## soil organic matter content\ndownload_bexis_dataset(id = 14446, name = \"soilorganicmatter_2011\", output_dir = data_dir)\n\n## soil bulk density\ndownload_bexis_dataset(id = 17086, name = \"soilbulkdensity_2011\", output_dir = data_dir)\n\n## rooting depth\ndownload_bexis_dataset(id = 4761, name = \"rootingdepth_2008\", output_dir = data_dir)\n\n\n\n\n\n\n\n\n\n\nScript for downloading PET data from DWD\n\n\n\n\n\nThe following script downloads files for the potential evapotranspiration from the DWD:\n\n\ndownload_pet.jl\n\ndata_dir = \"../data/\"\n\n# https://opendata.dwd.de/climate_environment/CDC/derived_germany/soil/daily/historical/\n# 164 - Angermünde = SCH\n# 3402 - Münsingen-Apfelstetten = ALB\n# 6305 - Mühlhausen = HAI\nids = [\n    \"164\",\n    \"3402\",\n    \"6305\",\n]\n\nfor id in ids\n    local url = \"https://opendata.dwd.de/climate_environment/CDC/derived_germany/soil/daily/historical/derived_germany_soil_daily_historical_$(id).txt.gz\"\n    filename = \"pet_$(id).txt.gz\"\n    download(url, joinpath(data_dir, filename))\nend\n\n\n\n\n\n\n\n\n\n\nProcessing PAR data from Google Earth Engine\n\n\n\n\n\nThe photosynthetic active radiation was processed with the following script on Google Earth Engine:\n\n\npar_extract.js\n\nfunction bufferPoints(radius, bounds) {\n    return function(pt) {\n        pt = ee.Feature(pt);\n        return bounds ? pt.buffer(radius).bounds() : pt.buffer(radius);\n    };\n}\n\nfunction zonalStats(ic, fc, params) {\n    // Initialize internal params dictionary.\n    var _params = {\n        reducer: ee.Reducer.mean(),\n        scale: null,\n        crs: null,\n        bands: null,\n        bandsRename: null,\n        imgProps: null,\n        imgPropsRename: null,\n        datetimeName: 'datetime',\n        datetimeFormat: 'YYYY-MM-dd HH:mm:ss'\n};\n\n// Replace initialized params with provided params.\nif (params) {\n    for (var param in params) {\n    _params[param] = params[param] || _params[param];\n    }\n}\n\n// Set default parameters based on an image representative.\nvar imgRep = ic.first();\nvar nonSystemImgProps = ee.Feature(null)\n    .copyProperties(imgRep).propertyNames();\nif (!_params.bands) _params.bands = imgRep.bandNames();\nif (!_params.bandsRename) _params.bandsRename = _params.bands;\nif (!_params.imgProps) _params.imgProps = nonSystemImgProps;\nif (!_params.imgPropsRename) _params.imgPropsRename = _params.imgProps;\n\n// Map the reduceRegions function over the image collection.\nvar results = ic.map(function(img) {\n    // Select bands (optionally rename), set a datetime & timestamp property.\n    img = ee.Image(img.select(_params.bands, _params.bandsRename))\n    .set(_params.datetimeName, img.date().format(_params.datetimeFormat))\n    .set('timestamp', img.get('system:time_start'));\n\n    // Define final image property dictionary to set in output features.\n    var propsFrom = ee.List(_params.imgProps)\n    .cat(ee.List([_params.datetimeName, 'timestamp']));\n    var propsTo = ee.List(_params.imgPropsRename)\n    .cat(ee.List([_params.datetimeName, 'timestamp']));\n    var imgProps = img.toDictionary(propsFrom).rename(propsFrom, propsTo);\n\n    // Subset points that intersect the given image.\n    var fcSub = fc.filterBounds(img.geometry());\n\n    // Reduce the image by regions.\n    return img.reduceRegions({\n    collection: fcSub,\n    reducer: _params.reducer,\n    scale: _params.scale,\n    crs: _params.crs\n    })\n    // Add metadata to each feature.\n    .map(function(f) {\n    return f.set(imgProps);\n    });\n}).flatten().filter(ee.Filter.notNull(_params.bandsRename));\n\nreturn results;\n}\n\n// -----------------------------------\nvar start_year = 2006\nvar end_year = 2022 \nvar MODIS_PAR = ee.ImageCollection('MODIS/061/MCD18C2')\n                .filter(\n                    ee.Filter.date(\n                    start_year + '-01-01', \n                    end_year + '-12-31'));            \n\n// -----------------------------------\nvar pts = ee.FeatureCollection([\n    ee.Feature(ee.Geometry.Point([13.75, 52.96]), {plot_id: 'SCH'}),\n    ee.Feature(ee.Geometry.Point([10.37, 51.25]), {plot_id: 'HAI'}),\n    ee.Feature(ee.Geometry.Point([9.41, 48.43]), {plot_id: 'ALB'})\n]);\nvar ptsExplo = pts.map(bufferPoints(10000, false));\n\n// -----------------------------------\nvar params = {\n    reducer: ee.Reducer.median(),\n    scale: 1000,\n    crs: 'EPSG:5243',\n    bands: ['GMT_0000_PAR', 'GMT_0300_PAR', 'GMT_0600_PAR', 'GMT_0900_PAR', 'GMT_1200_PAR', 'GMT_1500_PAR', 'GMT_1800_PAR', 'GMT_2100_PAR'],\n    bandsRename: ['PAR_00', 'PAR_03', 'PAR_06', 'PAR_09', 'PAR_12', 'PAR_15', 'PAR_18', 'PAR_21'],\n    datetimeName: 'date',\n    datetimeFormat: 'YYYY-MM-dd'\n};\nvar ptsModisStats = zonalStats(MODIS_PAR, ptsExplo, params);\n\n// -----------------------------------\nvar removeGeometry = function(feature) {\n    return feature.setGeometry(null);\n};\nvar final_output = ptsModisStats.map(removeGeometry);\n\n// -----------------------------------\nExport.table.toDrive({\n    collection: final_output,\n    folder: 'GEE', \n    description: 'PAR_' + start_year + '_' + end_year,\n    fileFormat: 'CSV'\n});  \n\n\n\n\n\n\n\n\n\n\nScript for downloading temperature and precipitation data from DWD\n\n\n\n\n\nThe following script downloads files for the potential evapotranspiration from the DWD:\n\n\ndownload_temperature_precipitation_dwd.jl\n\ndata_dir = \"../data/\"\n\nbase_url = \"https://opendata.dwd.de/climate_environment/CDC/observations_germany/climate/daily/kl/historical/\"\n\nfiles = [\n    \"tageswerte_KL_00164_19080517_20231231_hist.zip\",\n    \"tageswerte_KL_03402_19460101_20231231_hist.zip\",\n    \"tageswerte_KL_06305_20041201_20231231_hist.zip\"\n]\n\ntxt_names = [\n    \"produkt_klima_tag_19080517_20231231_00164.txt\",\n    \"produkt_klima_tag_19460101_20231231_03402.txt\",\n    \"produkt_klima_tag_20041201_20231231_06305.txt\"\n]\n\nids = [164, 3402, 6305]\n\nfor i in eachindex(files)\n    local my_url = base_url * files[i]\n    download(my_url, \"data.zip\")\n\n    local my_file = txt_names[i]\n    run(pipeline(`unzip -p data.zip $my_file`, stdout = \"$(data_dir)/temperature_precipitation_$(ids[i]).csv\"))\n    rm(\"data.zip\")\nend\n\n\n\n\n\n\n\n\n\n\nHow to download temperature and precipitation data from BExIS\n\n\n\n\n\nThe data can be manually downloaded from the BExIS data base with the climate tool, see Wöllauer et al. (2023).\nThe following yaml file shows which options were used for downloading:\n\n\ntemperature_precipitation_processing_settings.yaml\n\ncreation date: '2023-08-28T10:00:34.207273'\ntubedb version: 1.23.1\nregion:\n  id: BE\n  name: Exploratories\ngroups:\n- id: AEG\n  name: Schwäbische Alb Grünland\n- id: HEG\n  name: Hainich-Dün Grünland\n- id: SEG\n  name: Schorfheide Grünland\nplots:\n- AEG01\n- AEG02\n- AEG03\n- AEG04\n- AEG05\n- AEG06\n- AEG07\n- AEG08\n- AEG09\n- AEG10\n- AEG11\n- AEG12\n- AEG13\n- AEG14\n- AEG15\n- AEG16\n- AEG17\n- AEG18\n- AEG19\n- AEG20\n- AEG21\n- AEG22\n- AEG23\n- AEG24\n- AEG25\n- AEG26\n- AEG27\n- AEG28\n- AEG29\n- AEG30\n- AEG31\n- AEG32\n- AEG33\n- AEG34\n- AEG35\n- AEG36\n- AEG37\n- AEG38\n- AEG39\n- AEG40\n- AEG41\n- AEG42\n- AEG43\n- AEG44\n- AEG45\n- AEG46\n- AEG47\n- AEG48\n- AEG49\n- AEG50\n- HEG01\n- HEG02\n- HEG03\n- HEG04\n- HEG05\n- HEG06\n- HEG07\n- HEG08\n- HEG09\n- HEG10\n- HEG11\n- HEG12\n- HEG13\n- HEG14\n- HEG15\n- HEG16\n- HEG17\n- HEG18\n- HEG19\n- HEG20\n- HEG21\n- HEG22\n- HEG23\n- HEG24\n- HEG25\n- HEG26\n- HEG27\n- HEG28\n- HEG29\n- HEG30\n- HEG31\n- HEG32\n- HEG33\n- HEG34\n- HEG35\n- HEG36\n- HEG37\n- HEG38\n- HEG39\n- HEG40\n- HEG41\n- HEG42\n- HEG43\n- HEG44\n- HEG45\n- HEG46\n- HEG47\n- HEG48\n- HEG49\n- HEG50\n- SEG01\n- SEG02\n- SEG03\n- SEG04\n- SEG05\n- SEG06\n- SEG07\n- SEG08\n- SEG09\n- SEG10\n- SEG11\n- SEG12\n- SEG13\n- SEG14\n- SEG15\n- SEG16\n- SEG17\n- SEG18\n- SEG19\n- SEG20\n- SEG21\n- SEG22\n- SEG23\n- SEG24\n- SEG25\n- SEG26\n- SEG27\n- SEG28\n- SEG29\n- SEG30\n- SEG31\n- SEG32\n- SEG33\n- SEG34\n- SEG35\n- SEG36\n- SEG37\n- SEG38\n- SEG39\n- SEG40\n- SEG41\n- SEG42\n- SEG43\n- SEG44\n- SEG45\n- SEG46\n- SEG47\n- SEG48\n- SEG49\n- SEG50\nsensors:\n- P_RT_NRT\n- precipitation_radolan\n- Ta_200\ntime interval:\n  start: '*'\n  end: '*'\naggregation: day\nquality check: empirical\ninterpolation: true\ndata columns:\n- plotID\n- datetime\n- qualitycounter\ndata header: true\nall plots in one file: plots.csv\nadditional files:\n- sensor_description.csv\n- plot_description.csv\n- processing_settings.yaml\n\n\n\n\n\n\n\n\n\n\nData sources for the species traits\n\n\n\n\n\nParts of the traits data were download from BExIS from traits that were measured from plants in the field (specific leaf area, Prati, Goßner, and Neff (2021)) or in lab conditions (belowground traits, aboveground biomass per total biomass, Bergmann and Rillig (2022)). The potential plant height was taken from the LEDA trait database (Kleyer et al. (2008)). The leaf nitrogen content was downloaded from the TRY database (Kattge et al. (2020)).",
    "crumbs": [
      "Data of the Biodiversity Exploratories"
    ]
  },
  {
    "objectID": "data.html#where-to-get-the-data",
    "href": "data.html#where-to-get-the-data",
    "title": "Data of the Biodiversity Exploratories",
    "section": "",
    "text": "The data from the Biodiversity Exploraties can be downloaded from the BExIS data base. Also the metadata for all datasets is available there.\n\n\n\n\n\n\nScript for downloading all data sets from BExIS\n\n\n\n\n\nThe following R-script downloads all data sets from the Biodiversity Exploratories data base:\n\n\ndownload_bexis.R\n\n# install with:\n# devtools::install_github(\"BEXIS2/rBExIS\", subdir = \"rBExIS\")\nlibrary(rBExIS) \nlibrary(readr)\n\ndownload_bexis_dataset &lt;- function(id, name, output_dir){\n    dir.create(\"data/\", showWarnings = FALSE)\n    api_url &lt;- rBExIS:::get_api_url(\"/data/\")\n    table_data &lt;- content(rBExIS:::get_response(\"GET\", paste0(api_url, id)))\n    write_csv(table_data, paste0(output_dir, name, \".csv\"))\n}\n\nbexis.options(\"base_url\" = \"https://www.bexis.uni-jena.de/\")\ndata_dir = \"data/\"\n\n\n## approximate (public) coordinates \ndownload_bexis_dataset(id = 1000, name = \"approx_site_coordinates\", output_dir = data_dir)\n \n## management input for grazing and mowing\ndownload_bexis_dataset(id = 31715, name = \"management_input\", output_dir = data_dir)\ndownload_bexis_dataset(id = 25086, name = \"LUI_tool_input\", output_dir = data_dir)\n\n## cut biomass (botany core)\ndownload_bexis_dataset(id = 16209, name = \"biomass_2009\", output_dir = data_dir)\ndownload_bexis_dataset(id = 12706, name = \"biomass_2010\", output_dir = data_dir)\ndownload_bexis_dataset(id = 14346, name = \"biomass_2011\", output_dir = data_dir)\n\n## cut biomass (sade)\ndownload_bexis_dataset(id = 19812, name = \"biomass_2015_sade\", output_dir = data_dir)\ndownload_bexis_dataset(id = 23506, name = \"biomass_2017_sade\", output_dir = data_dir)\n\n## cut biomass (hedge II)\ndownload_bexis_dataset(id = 31138, name = \"biomass_2017_hainich_hedgeII\", output_dir = data_dir)\ndownload_bexis_dataset(id = 31139, name = \"biomass_2018_alb_hedgeII\", output_dir = data_dir)\n\n## vegetation\ndownload_bexis_dataset(id = 31389, name = \"vegetation_2008_2022\", output_dir = data_dir)\n\n## vegetation header data\ndownload_bexis_dataset(id = 6340, name = \"vegetation_header_data_2009\", output_dir = data_dir)\ndownload_bexis_dataset(id = 13486, name = \"vegetation_header_data_2010\", output_dir = data_dir)\ndownload_bexis_dataset(id = 14326, name = \"vegetation_header_data_2011\", output_dir = data_dir)\ndownload_bexis_dataset(id = 15588, name = \"vegetation_header_data_2012\", output_dir = data_dir)\ndownload_bexis_dataset(id = 16826, name = \"vegetation_header_data_2013\", output_dir = data_dir)\ndownload_bexis_dataset(id = 19807, name = \"vegetation_header_data_2014\", output_dir = data_dir)\ndownload_bexis_dataset(id = 19809, name = \"vegetation_header_data_2015\", output_dir = data_dir)\ndownload_bexis_dataset(id = 21187, name = \"vegetation_header_data_2016\", output_dir = data_dir)\ndownload_bexis_dataset(id = 31466, name = \"vegetation_header_data_2017\", output_dir = data_dir)\ndownload_bexis_dataset(id = 24166, name = \"vegetation_header_data_2018\", output_dir = data_dir)\ndownload_bexis_dataset(id = 26151, name = \"vegetation_header_data_2019\", output_dir = data_dir)\ndownload_bexis_dataset(id = 27426, name = \"vegetation_header_data_2020\", output_dir = data_dir)\ndownload_bexis_dataset(id = 31180, name = \"vegetation_header_data_2021\", output_dir = data_dir)\ndownload_bexis_dataset(id = 31387, name = \"vegetation_header_data_2022\", output_dir = data_dir)\n\n## leaf traits\ndownload_bexis_dataset(id = 24807, name = \"leaf_traits\", output_dir = data_dir)\n\n## root traits\ndownload_bexis_dataset(id = 26546, name = \"root_traits\", output_dir = data_dir)\n\n## soil nutrients\ndownload_bexis_dataset(id = 14446, name = \"soilnutrients_2011\", output_dir = data_dir)\ndownload_bexis_dataset(id = 18787, name = \"soilnutrients_2014\", output_dir = data_dir)\ndownload_bexis_dataset(id = 23846, name = \"soilnutrients_2017\", output_dir = data_dir)\ndownload_bexis_dataset(id = 31210, name = \"soilnutrients_2021\", output_dir = data_dir)\n\n## soil texture\ndownload_bexis_dataset(id = 14686, name = \"soiltexture_2011\", output_dir = data_dir)\n\n## soil organic matter content\ndownload_bexis_dataset(id = 14446, name = \"soilorganicmatter_2011\", output_dir = data_dir)\n\n## soil bulk density\ndownload_bexis_dataset(id = 17086, name = \"soilbulkdensity_2011\", output_dir = data_dir)\n\n## rooting depth\ndownload_bexis_dataset(id = 4761, name = \"rootingdepth_2008\", output_dir = data_dir)\n\n\n\n\n\n\n\n\n\n\nScript for downloading PET data from DWD\n\n\n\n\n\nThe following script downloads files for the potential evapotranspiration from the DWD:\n\n\ndownload_pet.jl\n\ndata_dir = \"../data/\"\n\n# https://opendata.dwd.de/climate_environment/CDC/derived_germany/soil/daily/historical/\n# 164 - Angermünde = SCH\n# 3402 - Münsingen-Apfelstetten = ALB\n# 6305 - Mühlhausen = HAI\nids = [\n    \"164\",\n    \"3402\",\n    \"6305\",\n]\n\nfor id in ids\n    local url = \"https://opendata.dwd.de/climate_environment/CDC/derived_germany/soil/daily/historical/derived_germany_soil_daily_historical_$(id).txt.gz\"\n    filename = \"pet_$(id).txt.gz\"\n    download(url, joinpath(data_dir, filename))\nend\n\n\n\n\n\n\n\n\n\n\nProcessing PAR data from Google Earth Engine\n\n\n\n\n\nThe photosynthetic active radiation was processed with the following script on Google Earth Engine:\n\n\npar_extract.js\n\nfunction bufferPoints(radius, bounds) {\n    return function(pt) {\n        pt = ee.Feature(pt);\n        return bounds ? pt.buffer(radius).bounds() : pt.buffer(radius);\n    };\n}\n\nfunction zonalStats(ic, fc, params) {\n    // Initialize internal params dictionary.\n    var _params = {\n        reducer: ee.Reducer.mean(),\n        scale: null,\n        crs: null,\n        bands: null,\n        bandsRename: null,\n        imgProps: null,\n        imgPropsRename: null,\n        datetimeName: 'datetime',\n        datetimeFormat: 'YYYY-MM-dd HH:mm:ss'\n};\n\n// Replace initialized params with provided params.\nif (params) {\n    for (var param in params) {\n    _params[param] = params[param] || _params[param];\n    }\n}\n\n// Set default parameters based on an image representative.\nvar imgRep = ic.first();\nvar nonSystemImgProps = ee.Feature(null)\n    .copyProperties(imgRep).propertyNames();\nif (!_params.bands) _params.bands = imgRep.bandNames();\nif (!_params.bandsRename) _params.bandsRename = _params.bands;\nif (!_params.imgProps) _params.imgProps = nonSystemImgProps;\nif (!_params.imgPropsRename) _params.imgPropsRename = _params.imgProps;\n\n// Map the reduceRegions function over the image collection.\nvar results = ic.map(function(img) {\n    // Select bands (optionally rename), set a datetime & timestamp property.\n    img = ee.Image(img.select(_params.bands, _params.bandsRename))\n    .set(_params.datetimeName, img.date().format(_params.datetimeFormat))\n    .set('timestamp', img.get('system:time_start'));\n\n    // Define final image property dictionary to set in output features.\n    var propsFrom = ee.List(_params.imgProps)\n    .cat(ee.List([_params.datetimeName, 'timestamp']));\n    var propsTo = ee.List(_params.imgPropsRename)\n    .cat(ee.List([_params.datetimeName, 'timestamp']));\n    var imgProps = img.toDictionary(propsFrom).rename(propsFrom, propsTo);\n\n    // Subset points that intersect the given image.\n    var fcSub = fc.filterBounds(img.geometry());\n\n    // Reduce the image by regions.\n    return img.reduceRegions({\n    collection: fcSub,\n    reducer: _params.reducer,\n    scale: _params.scale,\n    crs: _params.crs\n    })\n    // Add metadata to each feature.\n    .map(function(f) {\n    return f.set(imgProps);\n    });\n}).flatten().filter(ee.Filter.notNull(_params.bandsRename));\n\nreturn results;\n}\n\n// -----------------------------------\nvar start_year = 2006\nvar end_year = 2022 \nvar MODIS_PAR = ee.ImageCollection('MODIS/061/MCD18C2')\n                .filter(\n                    ee.Filter.date(\n                    start_year + '-01-01', \n                    end_year + '-12-31'));            \n\n// -----------------------------------\nvar pts = ee.FeatureCollection([\n    ee.Feature(ee.Geometry.Point([13.75, 52.96]), {plot_id: 'SCH'}),\n    ee.Feature(ee.Geometry.Point([10.37, 51.25]), {plot_id: 'HAI'}),\n    ee.Feature(ee.Geometry.Point([9.41, 48.43]), {plot_id: 'ALB'})\n]);\nvar ptsExplo = pts.map(bufferPoints(10000, false));\n\n// -----------------------------------\nvar params = {\n    reducer: ee.Reducer.median(),\n    scale: 1000,\n    crs: 'EPSG:5243',\n    bands: ['GMT_0000_PAR', 'GMT_0300_PAR', 'GMT_0600_PAR', 'GMT_0900_PAR', 'GMT_1200_PAR', 'GMT_1500_PAR', 'GMT_1800_PAR', 'GMT_2100_PAR'],\n    bandsRename: ['PAR_00', 'PAR_03', 'PAR_06', 'PAR_09', 'PAR_12', 'PAR_15', 'PAR_18', 'PAR_21'],\n    datetimeName: 'date',\n    datetimeFormat: 'YYYY-MM-dd'\n};\nvar ptsModisStats = zonalStats(MODIS_PAR, ptsExplo, params);\n\n// -----------------------------------\nvar removeGeometry = function(feature) {\n    return feature.setGeometry(null);\n};\nvar final_output = ptsModisStats.map(removeGeometry);\n\n// -----------------------------------\nExport.table.toDrive({\n    collection: final_output,\n    folder: 'GEE', \n    description: 'PAR_' + start_year + '_' + end_year,\n    fileFormat: 'CSV'\n});  \n\n\n\n\n\n\n\n\n\n\nScript for downloading temperature and precipitation data from DWD\n\n\n\n\n\nThe following script downloads files for the potential evapotranspiration from the DWD:\n\n\ndownload_temperature_precipitation_dwd.jl\n\ndata_dir = \"../data/\"\n\nbase_url = \"https://opendata.dwd.de/climate_environment/CDC/observations_germany/climate/daily/kl/historical/\"\n\nfiles = [\n    \"tageswerte_KL_00164_19080517_20231231_hist.zip\",\n    \"tageswerte_KL_03402_19460101_20231231_hist.zip\",\n    \"tageswerte_KL_06305_20041201_20231231_hist.zip\"\n]\n\ntxt_names = [\n    \"produkt_klima_tag_19080517_20231231_00164.txt\",\n    \"produkt_klima_tag_19460101_20231231_03402.txt\",\n    \"produkt_klima_tag_20041201_20231231_06305.txt\"\n]\n\nids = [164, 3402, 6305]\n\nfor i in eachindex(files)\n    local my_url = base_url * files[i]\n    download(my_url, \"data.zip\")\n\n    local my_file = txt_names[i]\n    run(pipeline(`unzip -p data.zip $my_file`, stdout = \"$(data_dir)/temperature_precipitation_$(ids[i]).csv\"))\n    rm(\"data.zip\")\nend\n\n\n\n\n\n\n\n\n\n\nHow to download temperature and precipitation data from BExIS\n\n\n\n\n\nThe data can be manually downloaded from the BExIS data base with the climate tool, see Wöllauer et al. (2023).\nThe following yaml file shows which options were used for downloading:\n\n\ntemperature_precipitation_processing_settings.yaml\n\ncreation date: '2023-08-28T10:00:34.207273'\ntubedb version: 1.23.1\nregion:\n  id: BE\n  name: Exploratories\ngroups:\n- id: AEG\n  name: Schwäbische Alb Grünland\n- id: HEG\n  name: Hainich-Dün Grünland\n- id: SEG\n  name: Schorfheide Grünland\nplots:\n- AEG01\n- AEG02\n- AEG03\n- AEG04\n- AEG05\n- AEG06\n- AEG07\n- AEG08\n- AEG09\n- AEG10\n- AEG11\n- AEG12\n- AEG13\n- AEG14\n- AEG15\n- AEG16\n- AEG17\n- AEG18\n- AEG19\n- AEG20\n- AEG21\n- AEG22\n- AEG23\n- AEG24\n- AEG25\n- AEG26\n- AEG27\n- AEG28\n- AEG29\n- AEG30\n- AEG31\n- AEG32\n- AEG33\n- AEG34\n- AEG35\n- AEG36\n- AEG37\n- AEG38\n- AEG39\n- AEG40\n- AEG41\n- AEG42\n- AEG43\n- AEG44\n- AEG45\n- AEG46\n- AEG47\n- AEG48\n- AEG49\n- AEG50\n- HEG01\n- HEG02\n- HEG03\n- HEG04\n- HEG05\n- HEG06\n- HEG07\n- HEG08\n- HEG09\n- HEG10\n- HEG11\n- HEG12\n- HEG13\n- HEG14\n- HEG15\n- HEG16\n- HEG17\n- HEG18\n- HEG19\n- HEG20\n- HEG21\n- HEG22\n- HEG23\n- HEG24\n- HEG25\n- HEG26\n- HEG27\n- HEG28\n- HEG29\n- HEG30\n- HEG31\n- HEG32\n- HEG33\n- HEG34\n- HEG35\n- HEG36\n- HEG37\n- HEG38\n- HEG39\n- HEG40\n- HEG41\n- HEG42\n- HEG43\n- HEG44\n- HEG45\n- HEG46\n- HEG47\n- HEG48\n- HEG49\n- HEG50\n- SEG01\n- SEG02\n- SEG03\n- SEG04\n- SEG05\n- SEG06\n- SEG07\n- SEG08\n- SEG09\n- SEG10\n- SEG11\n- SEG12\n- SEG13\n- SEG14\n- SEG15\n- SEG16\n- SEG17\n- SEG18\n- SEG19\n- SEG20\n- SEG21\n- SEG22\n- SEG23\n- SEG24\n- SEG25\n- SEG26\n- SEG27\n- SEG28\n- SEG29\n- SEG30\n- SEG31\n- SEG32\n- SEG33\n- SEG34\n- SEG35\n- SEG36\n- SEG37\n- SEG38\n- SEG39\n- SEG40\n- SEG41\n- SEG42\n- SEG43\n- SEG44\n- SEG45\n- SEG46\n- SEG47\n- SEG48\n- SEG49\n- SEG50\nsensors:\n- P_RT_NRT\n- precipitation_radolan\n- Ta_200\ntime interval:\n  start: '*'\n  end: '*'\naggregation: day\nquality check: empirical\ninterpolation: true\ndata columns:\n- plotID\n- datetime\n- qualitycounter\ndata header: true\nall plots in one file: plots.csv\nadditional files:\n- sensor_description.csv\n- plot_description.csv\n- processing_settings.yaml\n\n\n\n\n\n\n\n\n\n\nData sources for the species traits\n\n\n\n\n\nParts of the traits data were download from BExIS from traits that were measured from plants in the field (specific leaf area, Prati, Goßner, and Neff (2021)) or in lab conditions (belowground traits, aboveground biomass per total biomass, Bergmann and Rillig (2022)). The potential plant height was taken from the LEDA trait database (Kleyer et al. (2008)). The leaf nitrogen content was downloaded from the TRY database (Kattge et al. (2020)).",
    "crumbs": [
      "Data of the Biodiversity Exploratories"
    ]
  },
  {
    "objectID": "data.html#input-data",
    "href": "data.html#input-data",
    "title": "Data of the Biodiversity Exploratories",
    "section": "2 Input data",
    "text": "2 Input data\n\n2.1 Traits of species\n\n\n\n\n\n\n\nDescription\nData source\n\n\n\n\nSpecific leaf area [m² g⁻¹]\nPrati, Goßner, and Neff (2021)\n\n\nArbuscular mycorrhizal colonisation [-]\nBergmann and Rillig (2022)\n\n\nRoot surface area / aboveground biomass [m² g⁻¹]\nBergmann and Rillig (2022)\n\n\nAbove ground biomass per total biomass (abp) [-]\nBergmann and Rillig (2022)\n\n\nThe leaf biomass per aboveground biomass [-]\nset to 0.8 of abp\n\n\nPotential plant height [m]\nKleyer et al. (2008)\n\n\nLeaf nitrogen / leaf mass [mg g⁻¹]\nKattge et al. (2020)\n\n\n\n\n\n\n\n\n\nDetails on getting the species traits\n\n\n\n\n\nThe species traits were processed with the following script:\n\n\n1_input_traits.jl\n\ninclude(\"0_functions_load_traits.jl\")\n\n##### load tables\ndata_path = \"../data/\"\noutput_path = \"traits.csv\"\ndf_leaf = bexis_leaf_traits(data_path)\ndf_root = bexis_root_traits(data_path)\ndf_leda = LEDA_height(data_path)\ndf_try = load_lnc_try(data_path)\ndf_maxheight = CSV.read(data_path * \"maxheight_rothmaler.csv\", DataFrame)\n@transform! df_maxheight :maxheight = :maxheight .* u\"m\"\n@select! df_maxheight :species :maxheight\n\n##### Add root data for Taraxacum officinale\n# https://groot-database.github.io/GRooT/\n# https://github.com/GRooT-Database/GRooT-Data/\npush!(df_root, (\"Taraxacum officinale\", \"-\", 0.12u\"m^2/g\", 0.7, missing, 0.47, 0.53))\n\n##### join tables\ndf_bexis = outerjoin(df_leaf, df_root, on = :species, makeunique = true)\n@rtransform! df_bexis :sla = uconvert(u\"m^2 / g\", mean_missing(:sla1, :sla2))\n@select! df_bexis $(Not([:sla1, :sla2, :LA, :LDM]))\ndf = leftjoin(df_bexis, df_leda, on = :species)\nmanual_height!(df)\ndf1 = leftjoin(df, df_try, on = :species)\n\n## export from try datasets citations:\n# try_dataset_references(df.species)\n\n##### write output without units\ndf_out = @chain df1 begin\n    @orderby :species\n    @rename :rsa = :srsa\n    @rsubset !any(ismissing.([:rsa, :amc, :abp, :bbp, :sla, :height, :lnc]))\n    @rtransform begin\n        :rsa = round(typeof(:rsa), :rsa; digits = 4)\n        :amc = round(:amc; digits = 3)\n        :abp = round(:abp; digits = 3)\n        :bbp = round(:bbp; digits = 3)\n        :sla = round(typeof(:sla), :sla; digits = 5)\n        :height = round(typeof(:height), :height; digits = 4)\n        :lnc = round(typeof(:lnc), :lnc; digits = 1)\n    end\n    innerjoin(df_maxheight, on = :species)\n    # or : species .∉ Ref([\"Phragmites australis\", \"Phalaris arundinacea\"])\n    @subset :maxheight .&lt;= 2u\"m\"\n    @select Not([:leaf_species_orig, :root_species_orig, :species_leda, :height, :bbp])\nend\n\n### Poa annua has a very high SLA value, which is not realistic\n### We will replace it with the mean of the other poa species\n@subset df_out :sla .&gt; 0.03u\"m^2/g\"\n@subset df_out startswith.(:species, \"Poa\")\nmean([0.001, 0.014, 0.018])\ndf_out[df_out.species .== \"Poa annua\", :sla] .= 0.011u\"m^2/g\"\n\ndisallowmissing!(df_out)\ndf_out_wo_units = @rtransform df_out begin\n    :rsa = ustrip(:rsa)\n    :sla = ustrip(:sla)\n    :maxheight = ustrip(:maxheight)\n    :lnc = ustrip(:lnc)\nend\nCSV.write(output_path, df_out_wo_units)\n\n##### read file and add units\n@chain CSV.read(output_path, DataFrame) begin\n    @transform begin\n        :srsa = :srsa * u\"m^2 / g\"\n        :sla = :sla * u\"m^2 / g\"\n        :height = :height * u\"m\"\n        :lnc = :lnc * u\"mg / g\"\n    end\nend\n\nThe functions for loading the trait data are described in the following script:\n\n\n0_functions_load_traits.jl\n\nusing DataFrames, DataFramesMeta\nusing Unitful\nusing Statistics\nusing RCall\nimport CSV\nimport Dates\n\nfunction mean_missing(x1, x2)\n    if ismissing(x1)\n        return x2\n    elseif ismissing(x2)\n        return x1\n    else\n        return mean([x1, x2])\n    end\nend\n\nfunction bexis_leaf_traits(path)\n    @info \"Loading bexis leaf traits\"\n    df = CSV.read(path * \"leaf_traits.csv\", DataFrame;\n        missingstring=\"NA\")\n\n    # LA: leaf area [mm²]\n    # LFM: leaf fresh mass [g]\n    # LDM: leaf dry weight [g]\n    df = @chain df begin\n        @subset :system .== \"grassland\"\n        @rtransform begin\n            :LA = :total_area * u\"mm^2\"\n            :LDM = :dry_weight * u\"g\"\n            :leaf_species_orig = :pl_species\n            :leaf_species = :pl_species\n        end\n        @rename :plotID = :plotid_withzero\n        @subset :leaf_species .∉ Ref([\"Crataegus sp\", \"Secale sp\"])\n        @select :plotID :leaf_species :leaf_species_orig :LA :LDM\n        @rsubset !(ismissing(:LA) || ismissing(:LDM))\n    end\n    disallowmissing!(df)\n\n    df[df.leaf_species .== \"Festuca pratensis\", :leaf_species] .= \"Lolium pratense (Huds.) Darbysh.\"\n    df[df.leaf_species .== \"Festuca arundinacea\", :leaf_species] .= \"Lolium arundinaceum (Schreb.) Darbysh.\"\n    df[df.leaf_species .== \"Taraxacum sp\", :leaf_species] .= \"Taraxacum officinale F.H.Wigg.\"\n    df[df.leaf_species .== \"Prunella sp\", :leaf_species] .= \"Prunella vulgaris L.\"\n    df[df.leaf_species .== \"Primula elatior veris agg\", :leaf_species] .= \"Primula elatior Hill\"\n    df[df.leaf_species .== \"Bromus hordeaceus agg incl. B. commutatus\", :leaf_species] .= \"Bromus hordeaceus L.\"\n    df[df.leaf_species .== \"Rhinanthus agg\", :leaf_species] .= \"Rhinanthus minor L.\"\n\n    leaf_species = sort(unique(df.leaf_species))\n    # [println(s) for s in sort(unique(leaf_species))];\n    @rput leaf_species\n    R\"\"\"\n    library(TNRS)\n    leaf_species_df&lt;- TNRS(leaf_species)\n    NaN\n    \"\"\"\n    @rget leaf_species_df\n\n    leaf_species_df = @chain leaf_species_df begin\n        @rename begin\n            :leaf_species = :Name_submitted\n            :species = :Accepted_species\n        end\n        @select :species :leaf_species\n    end\n\n    @chain df begin\n        leftjoin(leaf_species_df, on = :leaf_species)\n        @groupby :species\n        @combine begin\n            :leaf_species_orig = first(:leaf_species_orig)\n            :LA = median(:LA)\n            :LDM = median(:LDM)\n        end\n        @orderby :species\n        @transform :sla1 = :LA ./ :LDM\n    end\nend\n\nfunction bexis_root_traits(path)\n    @info \"Loading bexis root traits\"\n    df = CSV.read(data_path * \"root_traits.csv\", DataFrame;\n        missingstring=\"NA\")\n\n    df = @chain df begin\n        @rename :root_species_orig = :species\n        @transform :species = convert.(String, :root_species_orig)\n    end\n\n    df[df.species .== \"Festuca_pratensis\", :species] .= \"Lolium pratense (Huds.) Darbysh.\"\n    df[df.species .== \"Festuca_arundinacea\", :species] .= \"Lolium arundinaceum (Schreb.) Darbysh.\"\n\n    root_species = df.species\n    # [println(s) for s in root_species];\n    @rput root_species\n    R\"\"\"\n    library(TNRS)\n    root_species_df&lt;- TNRS(root_species)\n    NaN\n    \"\"\"\n    @rget root_species_df\n\n    # BA:\n    #   below ground dry biomass / aboveground dry biomass\n    #   [ratio area/mass]\n    # SRSA:\n    #   root surface area / root dry biomass\n    #   [m²/g]\n    # AMC:\n    #   arbuscular mycorrhizal colonisation of the entire root system\n    #   [fraction, 0 to 1]\n    @chain df begin\n        @transform begin\n            :species = root_species_df.Accepted_species\n            :ba = :biomass_allocation\n            :srsa = :SRSA * u\"m^2 / g\"\n            :amc = :col\n            :sla2 = :SLA * u\"cm^2 / g\"\n        end\n        @rtransform :abp = 1 / (1 + :ba)\n        @rtransform :bbp = 1 - :abp\n        @orderby :species\n        @select :species :root_species_orig :srsa :amc :sla2 :abp :bbp\n    end\nend\n\nfunction LEDA_height(path)\n    if isfile(path *  \"canopy_height_LEDA.csv\")\n        df = CSV.read(path *  \"canopy_height_LEDA.csv\", DataFrame)\n        @transform! df :height = :height * u\"m\"\n        @subset! df .! ismissing.(:species)\n        return df\n    end\n\n    @info \"Loading leada height\"\n    function data_available(data)\n        f = isa.(data, Number)\n        f[f] .= .! isnan.(data[f]) .&& Inf .&gt; data[f] .&gt; 0\n        return f\n    end\n\n    df = CSV.read(path *  \"LEDA/canopy_height.txt\", DataFrame;\n        missingstring=[\"\", \"NA\"],\n        delim=\";\")\n\n    df[!, :height] .= NaN\n\n    ### Use single values\n    f1 = data_available(df[:, \"single value [m]\"])\n    df[f1, :height] .= df[f1, \"single value [m]\"]\n\n    ### even better mean values\n    f1 = data_available(df[:, \"mean CH [m]\"])\n    df[f1, :height] .= df[f1, \"mean CH [m]\"]\n\n    @rename! df :species_leda = $(Symbol(\"SBS name\"))\n    @transform! df :leda_species_orig = :species_leda\n\n    df[df.species_leda .== \"Festuca pratensis\", :species_leda] .= \"Lolium pratense (Huds.) Darbysh.\"\n    df[df.species_leda .== \"Festuca pratensis s. apennina\", :species_leda] .= \"Festuca pratensis subsp. apennina(De Not.) Hegi\"\n    df[df.species_leda .== \"Festuca arundinacea\", :species_leda] .= \"Lolium arundinaceum (Schreb.) Darbysh.\"\n    df[df.species_leda .== \"Senecio jacobaea\", :species_leda] .= \"Senecio vulgaris L.\"\n    df[df.species_leda .== \"Taraxacum Sec. Ruderalia\", :species_leda] .= \"Taraxacum officinale F.H.Wigg.\"\n\n    leda_species = sort(unique(df.species_leda))\n    @rput leda_species\n    R\"\"\"\n    library(TNRS)\n    leda_species_df &lt;- TNRS(leda_species)\n    NaN\n    \"\"\"\n    @rget leda_species_df\n\n    leda_species_df = @chain leda_species_df begin\n        @rename begin\n            :species_leda = :Name_submitted\n            :species = :Accepted_species\n        end\n        @select :species :species_leda\n    end\n\n    df = @chain df begin\n        leftjoin(leda_species_df, on = :species_leda)\n        @groupby :species\n        @combine begin\n            :species_leda = first(:species_leda)\n            :height = median(:height)\n        end\n    end\n\n    CSV.write(path *  \"LEDA/canopy_height_sub.csv\", df)\n    @transform! df :height = :height * u\"m\"\n\n    return df\nend\n\nfunction manual_height!(df)\n    species_without_height = [\"Poa trivialis\", \"Helictotrichon pubescens\",\n        \"Veronica teucrium\", \"Tripleurospermum inodorum\", \"Rumex acetosella\",\n        \"Medicago falcata\", \"Carex vulpina\"]\n    new_height = [0.3, 0.6, 0.5, 0.5, 0.2, 0.5, 0.7]u\"m\"\n\n    for i in eachindex(new_height)\n        s = species_without_height[i]\n        v = new_height[i]\n        df[df.species .== s, :height] .= v\n    end\n\n    return df\nend\n\nfunction load_lnc_try(path)\n    @info \"Loading try lnc\"\n\n    if isfile(path *  \"Leaf_nitrogen_content_TRY.csv\")\n        df = CSV.read(path *  \"Leaf_nitrogen_content_TRY.csv\", DataFrame)\n        @transform! df :lnc = :lnc * u\"mg/g\"\n        @subset! df .! ismissing.(:species)\n        return df\n    end\n\n    try_df = CSV.read(path *  \"TRY/33838.txt\", DataFrame;\n        missingstring=[\"\", \"NA\"],\n        delim=\"\\t\")\n\n    try_sub_df = @chain try_df begin\n        @subset .! ismissing.(:AccSpeciesName)\n        @subset .! ismissing.(:TraitName)\n        @subset .! ismissing.(:StdValue)\n        @select :AccSpeciesName :StdValue :TraitName\n    end\n    disallowmissing!(try_sub_df)\n\n    try_species = unique(try_sub_df.AccSpeciesName)\n    @rput try_species\n    R\"\"\"\n    library(TNRS)\n    try_species_df&lt;- TNRS(try_species)\n    NaN\n    \"\"\"\n    @rget try_species_df\n\n    try_species_sub_df = @chain try_species_df begin\n        @rename begin\n            :AccSpeciesName = :Name_submitted\n            :species = :Accepted_species\n        end\n        @orderby :species\n        @select :species :AccSpeciesName\n    end\n\n    df = @chain try_sub_df begin\n        leftjoin(try_species_sub_df, on = \"AccSpeciesName\")\n        @subset :TraitName .== \"Leaf nitrogen (N) content per leaf dry mass\"\n        @groupby :species\n        @combine :lnc = median(:StdValue)\n        @subset .! ismissing.(:species)\n    end\n\n    CSV.write(path *  \"TRY/33838_sub.csv\", df)\n    @transform! df :lnc = :lnc * u\"mg/g\"\n\n    return df\nend\n\n### export citation from TRY\nfunction try_dataset_references(species)\n    try_df = CSV.read(data_path *  \"TRY/33838.txt\", DataFrame;\n                    missingstring=[\"\", \"NA\"], delim=\"\\t\")\n\n    @chain try_df begin\n        @transform :species = :SpeciesName\n        @subset :species .∈ Ref(species)\n        @subset :TraitName .== \"Leaf nitrogen (N) content per leaf dry mass\"\n        @groupby :Dataset :Reference\n        @combine begin\n            :n = length(:Dataset)\n            :r = first(:Reference)\n        end\n        @orderby :n\n    end\nend\n\nfunction convert_id(id)\n    a = first.(id, 3)\n    b = chop(id, head = 3, tail = 0)\n    b = lpad(b, 2, \"0\")\n    return a * b\nend\n\nfunction to_numeric(d::Dates.Date)\n    daysinyear = Dates.daysinyear(Dates.year(d))\n    return Dates.year(d) + (Dates.dayofyear(d) - 1) / daysinyear\nend\n\nfunction load_veg_df(path)\n    veg_df = CSV.read(path * \"vegetation_2008_2022.csv\", DataFrame,\n        missingstring = [\"\", \"NA\"])\n\n    veg_df = @chain veg_df begin\n        @subset .! ismissing.(:Cover)\n        @subset :Cover .&gt; 0\n\n        @rename begin\n            :species = :Species\n            :year = :Year\n            :cover = :Cover\n            :plotID = :Useful_EP_PlotID\n        end\n        @select :plotID :year :species :cover\n        @orderby :plotID :year :species\n    end\n\n    veg_df[veg_df.species .== \"Festuca_pratensis\", :species] .= \"Lolium pratense (Huds.) Darbysh.\"\n    veg_df[veg_df.species .== \"Festuca_arundinacea\", :species] .= \"Lolium arundinaceum (Schreb.) Darbysh.\"\n    veg_df[veg_df.species .== \"Senecio_jacobaea\", :species] .= \"Jacobaea vulgaris Gaertn.\"\n    veg_df[veg_df.species .== \"Trifolium_campestre/dubium_aggr.\", :species] .= \"Trifolium dubium Sibth.\"\n    veg_df[veg_df.species .== \"Vicia_cf_lathyroides\", :species] .= \"Vicia lathyroides L.\"\n    veg_df[veg_df.species .== \"Geum_rivale/urbanum_aggr.\", :species] .= \"Geum urbanum L.\"\n    veg_df[veg_df.species .== \"Ononis_repens/spinosa_aggr.\", :species] .= \"Ononis spinosa L.\"\n    veg_df[veg_df.species .== \"Geranium_cf_pusillum\", :species] .= \"Geranium pusillum L.\"\n    veg_df[veg_df.species .== \"Primula_elatior/veris/aggr.\", :species] .= \"Primula elatior Hill\"\n\n    veg_species = unique(veg_df.species)\n    @rput veg_species\n    R\"\"\"\n    library(TNRS)\n    veg_species_df &lt;- TNRS(veg_species)\n    NaN\n    \"\"\"\n    @rget veg_species_df\n\n    veg_species_df = @chain veg_species_df begin\n        @rename begin\n        :species = :Accepted_species\n        :veg_orig_name = :Name_submitted\n        end\n        @subset :species .!== \"\"\n        @select :species :veg_orig_name\n    end\n\n    return veg_df, veg_species_df\nend\n\nfunction load_vegetation_date_df(path)\n    ep_plots = [\"$(explo)\" * lpad(i, 2, \"0\") for i in 1:50 for explo in [\"HEG\", \"SEG\", \"AEG\"]]\n    plot_df = DataFrame(plotID = ep_plots)\n\n    datasets = [\"vegetation_header_data_$y.csv\" for y in 2009:2021]\n\n    date_col = [fill(:Date, 2)...\n        fill(:date, 3)...\n        fill(missing, 4)...\n        fill(:date_releves, 4)...]\n    id_cols = [:EPID\n        fill(:EpPlotID, 8)...\n        fill(:Ep_PlotID, 4)...]\n    dfs = []\n\n    for (i, file) in enumerate(datasets)\n        df = CSV.read(path * file,\n            DataFrame;\n            missingstring = [\"\", \"NA\"])\n\n        if ismissing(date_col[i])\n            doy = df.day_of_year\n            doy[ismissing.(doy)] .= mean(.!ismissing(doy))\n            df.date = @. Dates.Date(df.year) + Dates.Day(doy)\n        else\n            df.date = df[:, date_col[i]]\n        end\n\n        df = @chain df begin\n            @transform :plotID = convert_id.($(id_cols[i]))\n            @select :plotID :date\n            rightjoin(plot_df, on = :plotID)\n        end\n\n        if any(ismissing.(df.date))\n            selected_dates = df[.!ismissing.(df.date), :date]\n            year = Dates.year(selected_dates[1])\n            mean_doy = Int(median(Dates.dayofyear.(selected_dates)))\n            df[ismissing.(df.date), :date] .= Dates.Date(year) + Dates.Day(mean_doy)\n        end\n\n        unique!(df, :plotID)\n\n        # @show length(unique(df.plotID))\n        push!(dfs, df)\n    end\n    date_df = vcat(dfs...)\n    date_df.year = Dates.year.(date_df.date)\n    date_df.numeric_date = to_numeric.(date_df.date)\n    return date_df\nend\n\n\n\n\n\n\nCode\nimport GrasslandTraitSim as sim\nimport Dates\nusing PairPlots\nusing DataFrames, DataFramesMeta\nusing Statistics\nusing CairoMakie\n\ntraits = sim.input_traits()\ndf = DataFrame(traits)\n\npairplot( \n    df =&gt; (\n        PairPlots.Scatter(color = (:blue, 0.5), markersize = 7), \n        PairPlots.Correlation(; digits = 2, position=PairPlots.Makie.Point2f(0.2, 1.0)),\n        PairPlots.MarginDensity(),\n        PairPlots.MarginHist(color = (:black, 0.2)),\n        PairPlots.MarginConfidenceLimits()))\n\n\n\n\n\n\n\n\n\n\n\n2.2 Daily abiotic conditions\nFor the first years from 2006 - 2008 no measurement directly from the sites were available. Therefore, the data was downloaded from the German Weather Service (DWD). The closest wheater station for each region (Schorfheife-Chorin, Hainich, Schwäbische Alb) was chosen. From 2009 to 2022, the data was used from the BExIS database mostly with measurements directly from the grassland sites (50 sites per region).\n\n\n\n\n\n\nDetails on loading temperature and precipitation data from DWD\n\n\n\n\n\nThe data was processed with the following script:\n\n\ntemperature_precipitation_dwd.jl\n\nimport CSV, Dates\nusing DataFrames, DataFramesMeta\nusing Statistics\n\nfunction read_dwd_temp(path; startyear = 2006, endyear = 2008, explo_str)\n    df = CSV.read(path, DataFrame;\n                  types = Dict(2 =&gt; Dates.Date),\n                  dateformat=\"yyyymmdd\",\n                  missingstring = \"-999\",\n                  delim = \";\",\n                  stripwhitespace=true)\n\n    # TMK mean temperature of the air at 2m in °C\n    # RSK sum of precipitation in mm\n\n    df_sub = @chain df begin\n        @rename begin\n            :dwd_stations_id = :STATIONS_ID\n            :date = :MESS_DATUM\n            :temperature = :TMK\n            :precipitation = :RSK\n        end\n        @transform :explo = explo_str\n        @subset endyear .&gt;= Dates.year.(:date) .&gt;= startyear\n        @select(:explo, :date, :temperature, :precipitation, :dwd_stations_id)\n    end\n    disallowmissing!(df_sub)\n\n    return df_sub\nend\n\ndata_path = \"../data\"\nsch_path = \"$data_path/temperature_precipitation_164.csv\"\nalb_path = \"$data_path/temperature_precipitation_3402.csv\"\nhai_path = \"$data_path/temperature_precipitation_6305.csv\"\n\ndf_sch = read_dwd_temp(sch_path; explo_str = \"SCH\")\ndf_alb = read_dwd_temp(alb_path; explo_str = \"ALB\")\ndf_hai = read_dwd_temp(hai_path; explo_str = \"HAI\")\n\n# move the file to assets/data/input\nvcat(df_sch, df_alb, df_hai) |&gt; CSV.write(\"temperature_precipitation_dwd.csv\")\n\n\n\n\n\n\n\n\n\n\nDetails on loading temperature and precipitation data from BExIS\n\n\n\n\n\nThe data was processed with the following script:\n\n\ntemperature_precipitation_dwd.jl\n\nimport CSV, Dates\nusing DataFrames, DataFramesMeta\nusing Statistics\n\ndata_path = \"../data/\"\n\ndf = CSV.read(data_path * \"exploratories_climate/plots.csv\",\n    DataFrame,\n    missingstring = [\"NA\"],\n    dateformat = \"dd/mm/yyyy\",)\ndf.explo = first.(df.plotID)\n\nmedian_temp = @chain df begin\n    @subset .!ismissing.(:Ta_200)\n    groupby(_, [:explo, :datetime])\n    @combine :median_Ta_200 = median(:Ta_200)\nend\n\ndf_sub = @chain df begin\n    leftjoin(_, median_temp, on = [:explo, :datetime])\n    @rtransform :precipitation = ismissing(:P_RT_NRT) ? :precipitation_radolan : :P_RT_NRT\n\n    ## just for the day 2020-02-06\n    @rtransform :precipitation = ismissing(:precipitation) ? 0.0 : :precipitation\n\n    @rtransform :Ta_200 = ismissing(:Ta_200) ? :median_Ta_200 : :Ta_200\n    @rename begin\n        :date = :datetime\n        :temperature = :Ta_200\n    end\n    @transform begin\n        :year = Dates.year.(:date)\n        :doy = Dates.dayofyear.(:date)\n        :temperature = round.(:temperature, digits = 1)\n        :precipitation = round.(:precipitation, digits = 1)\n    end\n    @subset 2009 .&lt;= :year .&lt;= 2022\n    @orderby :date\n    @select(:plotID, :date, :year, :doy, :temperature, :precipitation)\nend\ndisallowmissing!(df_sub)\n\n## values look plausible!\n# using CairoMakie\n# display(hist(df_sub.temperature; bins=100))\n# display(hist(df_sub.soiltemperature; bins=100))\n# display(hist(df_sub.precipitation; bins=100))\n\n# move file to assets/data/input\nCSV.write(\"temperature_precipitation.csv\", df_sub)\n\n\n\n\nEstimates of the photosynthetically active radiation (PAR) are available with a three hours resolution. A quadratic regression was fitted to the data and used to estimate the daily sum of PAR. The daily PAR equals the area under the quadratic regression curve. The spatial resolution of the gridded data set is not high enough to describes differences on the plot level, therefore the daily PAR values were calculated per region (Exploratories: Schorfheide-Chorin, Hainich, Schwäbische Alb).\n\n\n\n\n\n\nDetails on deriving the PAR\n\n\n\n\n\nA quadratic regression was fitted to the data with the following script:\n\n\npar.jl\n\nusing DataFrames, DataFramesMeta\nusing CairoMakie\nusing Polynomials\nusing Statistics\nusing Unitful\n\nimport CSV\nimport Dates\n\nfunction PAR_data(path; startyear = 2006, endyear = 2022, show_plot = false)\n    df_input = CSV.read(path * \"PAR_2006_2022.csv\", DataFrame; missingstring = \"-1\")\n    @select! df_input $(r\"^PAR\") :plot_id :date\n\n    df = @chain df_input begin\n        @transform :PAR = daily_PAR_sum(df_input; show_plot)\n        @rename :explo = :plot_id\n        @select :date :explo :PAR\n    end\n    date_range = Dates.Date(startyear):Dates.lastdayofyear(Dates.Date(endyear))\n    df_prep = DataFrame(date = repeat(date_range, 3),\n        explo = repeat([\"HAI\", \"ALB\", \"SCH\"], inner = length(date_range)))\n    df_prep.doy = Dates.dayofyear.(df_prep.date)\n    df_prep.year = Dates.year.(df_prep.date)\n\n    df_final = leftjoin(df_prep, df, on = [:date, :explo])\n\n    df_median = @chain df_final begin\n        @subset .!ismissing.(:PAR)\n        groupby(_, :doy)\n        @combine :PAR_median = median(:PAR)\n    end\n\n    df = @chain df_final begin\n        leftjoin(_, df_median, on = :doy)\n        @rtransform :PAR = ismissing(:PAR) ? :PAR_median : :PAR\n        @transform :PAR = uconvert.(u\"MJ / ha / d\", :PAR)\n        @transform :PAR = convert.(Int64, round.(ustrip.(:PAR), digits = 0))\n        @transform :year = Dates.year.(:date)\n        @orderby :date\n        @select :date :year :explo :PAR\n    end\n\n    CSV.write(\"par.csv\", df)\n\n    return df\nend\n\nfunction daily_PAR_sum(df; show_plot)\n    PAR_sum = Quantity{Float64}[]\n\n    for n in 1:nrow(df)\n        if show_plot\n            plot_par_sum_approximation(df, n)\n        end\n\n        area = area_under_curve(Array(df[n, 1:8]))\n\n        push!(PAR_sum, area)\n    end\n\n    return PAR_sum\nend\n\n\nfunction area_under_curve(PAR_measures; return_polygon = false)\n    hours = collect(0:3.0:21)\n    number_positive = PAR_measures .&gt; 0\n\n    left_no_par = findfirst(PAR_measures .!= 0) -1\n    right_no_par = findfirst(PAR_measures[4:end] .== 0) + 3\n    f = left_no_par:right_no_par\n    p = Polynomials.fit(hours[f], PAR_measures[f], 2)\n\n    ##### Integral\n    roots_par = roots(p)\n    p1 = integrate(p)\n    F_a = p1(roots_par[1])\n    F_b = p1(roots_par[2])\n    area = (F_b - F_a) / 1e6 * 60^2\n\n    ##### 2nd option: Riemann sum, 1 s -&gt; polynomial interpolation\n    # tpoints = uconvert.(u\"hr\", collect(1.0:60*60*24) * u\"s\") / u\"hr\"\n    # polygon_y = p.(tpoints)\n    # area1 = sum(polygon_y[polygon_y .&gt; 0]) / 1e6\n\n    ##### 3rd option: Riemann sum 3 hours -&gt; no interpolation\n    # manual_m = sum(PAR_measures .* 10800) / 1e6\n\n    if return_polygon\n        return p\n    else\n        return area .* u\"MJ / m^2 / d\"\n    end\nend\n\nfunction plot_par_sum_approximation(df, n)\n    hours = 0:3:21\n    PAR_measures = Array(df[n, 1:8])\n    orig_measures = copy(PAR_measures)\n\n    p = area_under_curve(PAR_measures;\n        return_polygon = true)\n\n    fig = Figure()\n    Axis(fig[1, 1])\n\n\n    t = collect(0:0.001:24)\n    pred = p.(t)\n    pred_filter = pred .&gt; 0\n\n    lines!(t[pred_filter], pred[pred_filter])\n    band!(t[pred_filter], 0, pred[pred_filter];\n        color = (:blue, 0.2))\n    scatter!(hours, orig_measures;\n        markersize = 15,\n        color = :coral3)\n\n    display(fig)\n\n    return nothing\nend\n\n\nlet\n    path = \"../data/\"\n\n    # move file to /assets/data/input\n    PAR_data(path)\nend\n\n\n\n\nThe potential evapotranspiration (PET) values were estimated by the agrometeorological model AMBAV, the VPGB variable (“potential evapotranspiration over gras”) is used here. Estimates of PET are available for different weather stations in Germany. The closest weather station of each Exploratory was chosen to get the daily PET values.\n\n\n\n\n\n\nDetails on loading PET\n\n\n\n\n\nThe data was processed with the following script:\nimport CSV, Dates\nusing DataFrames, DataFramesMeta\n\n\nfunction load_soil(path)\n    # https://opendata.dwd.de/climate_environment/CDC/derived_germany/soil/daily/historical/\n    # 164 - Angermünde = SCH\n    # 3402 - Münsingen-Apfelstetten = ALB\n    # 6305 - Mühlhausen = HAI\n\n    # VPGB - potential evapotranspiration over gras (AMBAV)\n    # BF10 - soil moisture under grass and sandy loam\n    #        between 0 and 10 cm depth in % plant useable water\n    # BFGSL - soil mosture under grass and sandy loam up to 60\n    #         cm depth (AMBAV)\n\n    fs = [\n        \"pet_164.txt.gz\",\n        \"pet_3402.txt.gz\",\n        \"pet_6305.txt.gz\",\n    ]\n    station = [\n        \"Angermünde\",\n        \"Münsingen-Apfelstetten\",\n        \"Eisenach\",\n    ]\n    explo = [\"SCH\", \"ALB\", \"HAI\"]\n\n    final_df = DataFrame()\n\n    for i in 1:3\n        p = joinpath(path, fs[i])\n        df = CSV.read(p,\n            DataFrame;\n            dateformat = \"yyyymmdd\",\n            types = Dict(:Datum =&gt; Dates.Date))\n        df_transformed = @chain df begin\n                               @select(:Stationsindex, :Datum, :VPGB, :BF10, :BFGSL)\n                               @transform(\n                                   :weather_station=station[i],\n                                   :doy=Dates.dayofyear.(:Datum),\n                                   :year=Dates.year.(:Datum),\n                                   :explo=explo[i])\n                               @select(\n                                   :explo,\n                                   :weather_station,\n                                   :weather_station_index=:Stationsindex,\n                                   :date=:Datum,\n                                   :year,\n                                   :doy,\n                                   :VPGB,\n                                   :BF10,\n                                   :BFGSL)\n        end\n\n\n        final_df = vcat(final_df, df_transformed)\n    end\n\n    return final_df\nend\n\nfunction load_PET_input(path; years)\n    df = load_soil(path)\n\n    @chain df begin\n        @subset :year .∈ Ref(years)\n        @rename :PET = :VPGB\n        @select :explo :date :year :PET\n        @orderby :date\n    end\nend\n\n\ndata_path = \"../data/\"\nload_PET_input(data_path; years = 2006:2022) |&gt; CSV.write(\"pet.csv\")\n\n\n\n\n\n\n\n\n\n\n\nVariable\nDescription\ndata source\n\n\n\n\ntemperature[t, plot]\nTemperature [°C]\nWöllauer et al. (2023)\n\n\nprecipitation[t, plot]\nPrecipitation [mm d⁻¹]\nWöllauer et al. (2023)\n\n\nPAR[t, region]\nPhotosynthetically active radiation [MJ ha⁻¹ d⁻¹]\nWang (2021)\n\n\nPET[t, region]\nPotential evapotranspiration [mm d⁻¹]\nDWD Climate Data Center (2019)\n\n\n\n\n\n2.3 Daily management variables\nThe management data was downloaded from BExIS and the mowing and grazing events were extracted. Exact dates were avaible for mowing. For grazing, only the start month, grazing intensity and the number of days grazed were available.\n\n\n\n\n\n\nDetails on mowing\n\n\n\n\n\nThe mowing data was processed with the following script:\nusing DataFrames\nusing DataFramesMeta\nimport CSV\nimport Dates\n\nfunction convert_id(id)\n    a = first.(id, 3)\n    b = chop(id, head=3, tail=0)\n    b = lpad(b, 2, \"0\")\n    return a * b\nend\n\nfunction isdate(x)\n    if ismissing(x)\n        return false\n    end\n    return isnothing(tryparse(Dates.Date, x, Dates.dateformat\"yyy-mm-dd\")) ? false : true\nend\n\n\nfunction load_mowing(path)\n    lui_df = CSV.read(\n        path * \"LUI_tool_input.csv\",\n        DataFrame)\n\n    df = CSV.read(\n        path * \"management_input.csv\",\n        DataFrame;\n        missingstring=[\"\", \"NA\"]);\n\n    df = mapcols(col -&gt; replace(col, \"-1\" =&gt; missing), df)\n    df = mapcols(col -&gt; replace(col, -1 =&gt; missing), df)\n\n    mowing_df = @chain df begin\n        @select(:Year, :EP_PlotID,\n            $(r\"DateCut\"), $(r\"CutHeight_cm\"))\n        innerjoin(@select(lui_df, :Year, :EP_PlotID, :TotalMowing),\n            _,\n            on = [:Year, :EP_PlotID])\n        sort(:EP_PlotID)\n        disallowmissing!(:Year)\n    end\n\n    for i in 1:5\n        mowing_df[:, \"MowingDay$i\"] = Array{Union{Missing, Int64}}(missing, nrow(mowing_df))\n\n        mowing_filter = isdate.(mowing_df[:, \"DateCut$i\"])\n        mowing_dates = Dates.Date.(mowing_df[mowing_filter, \"DateCut$i\"])\n        mowing_df[mowing_filter, \"MowingDay$i\"] .= Dates.dayofyear.(mowing_dates)\n\n        heights = copy(mowing_df[: ,\"CutHeight_cm$i\"])\n        heights = convert(Vector{Union{Missing, Float64}}, heights)\n        f1 = .! ismissing.(heights) .&& heights .&lt; 3.0\n        heights[f1] .= missing\n\n        f2 = ismissing.(heights) .&& mowing_filter\n        heights[f2] .= 7.5\n        mowing_df[!, \"CutHeight_cm$i\"] = heights\n    end\n\n    @select! mowing_df $(Not(r\"DateCut\"))\n\n    mowing_validation = @chain mowing_df begin\n        @transform :EP_PlotID = convert_id.(:EP_PlotID)\n        @rename begin\n            :plotID = :EP_PlotID\n            :year = :Year\n        end\n        @orderby :year\n    end\n\n    return mowing_validation\nend\n\ndf = load_mowing(\"../data/\")\n\n# move to GrasslandTraitSim/assets/data/input/\nCSV.write(\"mowing.csv\", df)\n\n\n\n\n\n\n\n\n\nDetails on grazing\n\n\n\n\n\nThe grazing data was processed with the following script:\nusing DataFrames\nusing DataFramesMeta\nusing CairoMakie\nimport CSV\nimport Dates\n\nfunction convert_id(id)\n    a = first.(id, 3)\n    b = chop(id, head=3, tail=0)\n    b = lpad(b, 2, \"0\")\n    return a * b\nend\n\nfunction convert_month(str)\n    if ismissing(str)\n        return missing\n    end\n\n    month_strs = [\n        \"Januar\", \"Februar\", \"Maerz\", \"April\", \"Mai\", \"Juni\",\n        \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"]\n\n    return findfirst(str .== month_strs)\nend\n\n\nfunction supplementary_feeding(path)\n    # supplementary_feeding.csv was created from https://www.bexis.uni-jena.de/ddm/data/Showdata/26487\n    df = CSV.read(\n        path * \"supplementary_feeding.csv\",\n        DataFrame)\n\n    @rename! df :plotID = :EP_PlotID\n    @rename! df :year = :Year\n\n\n    df_summarized = @chain df begin\n        @groupby :plotID\n        @combine :supplementary_feeding = any(:SupplementaryFeeding)\n    end\n\n    return df, df_summarized\nend\n\nfunction load_grazing(path)\n    lui_df = CSV.read(\n        path * \"LUI_tool_input.csv\",\n        DataFrame)\n\n    df = CSV.read(\n        path * \"management_input.csv\",\n        DataFrame;\n        missingstring=[\"\", \"NA\"]);\n\n    df = mapcols(col -&gt; replace(col, \"-1\" =&gt; missing), df)\n    df = mapcols(col -&gt; replace(col, -1 =&gt; missing), df)\n    df = mapcols(col -&gt; replace(col, \"ja\" =&gt; true), df)\n    df = mapcols(col -&gt; replace(col, \"nein\" =&gt; false), df)\n\n    selected_columns = [\n        :Year, :EP_PlotID, :SizeManagementUnit,\n        :AllYearGrazing, :StartGrazing, :GrazingType,\n        :StartGrazingPeriod1,\n        :StartGrazingPeriod2,\n        :StartGrazingPeriod3,\n        :StartGrazingPeriod4,\n        :LivestockUnits1, :DayGrazing1, :GrazingArea1,\n        :LivestockUnits2, :DayGrazing2, :GrazingArea2,\n        :LivestockUnits3, :DayGrazing3, :GrazingArea3,\n        :LivestockUnits4, :DayGrazing4, :GrazingArea4,\n    ]\n\n    col_filter = Symbol.(names(df)) .∈ Ref(selected_columns)\n    df = df[!, col_filter]\n    df.AllYearGrazing[ismissing.(df.AllYearGrazing)] .= false\n    df.GrazingType[ismissing.(df.GrazingType)] .= \"\"\n\n\n    ## 2020: AEG09 grazing of period 1 was written to grazing period 2\n    df[findall(df.Year .== 2020 .&& df.EP_PlotID .== \"AEG9\"), :StartGrazingPeriod1] .= \"Mai\"\n    df[findall(df.Year .== 2020 .&& df.EP_PlotID .== \"AEG9\"), :DayGrazing1] .= 15\n    df[findall(df.Year .== 2020 .&& df.EP_PlotID .== \"AEG9\"), :LivestockUnits1] .= 70\n\n    df[findall(df.Year .== 2020 .&& df.EP_PlotID .== \"AEG9\"), :StartGrazingPeriod2] .= missing\n    df[findall(df.Year .== 2020 .&& df.EP_PlotID .== \"AEG9\"), :DayGrazing2] .= missing\n    df[findall(df.Year .== 2020 .&& df.EP_PlotID .== \"AEG9\"), :LivestockUnits2] .= missing\n\n\n    df = @chain df begin\n        innerjoin(@select(lui_df, :Year, :EP_PlotID, :TotalGrazing), _,\n                  on = [:Year, :EP_PlotID])\n        @rtransform :EP_PlotID = convert_id(:EP_PlotID)\n        @orderby :Year :EP_PlotID\n        @rtransform begin\n            :DayGrazing1 = ismissing(:DayGrazing1) ? 0 : :DayGrazing1\n            :DayGrazing2 = ismissing(:DayGrazing2) ? 0 : :DayGrazing2\n            :DayGrazing3 = ismissing(:DayGrazing3) ? 0 : :DayGrazing3\n            :DayGrazing4 = ismissing(:DayGrazing4) ? 0 : :DayGrazing4\n            :LivestockUnits1 = ismissing(:LivestockUnits1) ? 0 : :LivestockUnits1\n            :LivestockUnits2 = ismissing(:LivestockUnits2) ? 0 : :LivestockUnits2\n            :LivestockUnits3 = ismissing(:LivestockUnits3) ? 0 : :LivestockUnits3\n            :LivestockUnits4 = ismissing(:LivestockUnits4) ? 0 : :LivestockUnits4\n            :GrazingArea1 = ismissing(:GrazingArea1) ? :SizeManagementUnit : :GrazingArea1\n            :GrazingArea2 = ismissing(:GrazingArea2) ? :SizeManagementUnit : :GrazingArea2\n            :GrazingArea3 = ismissing(:GrazingArea3) ? :SizeManagementUnit : :GrazingArea3\n            :GrazingArea4 = ismissing(:GrazingArea4) ? :SizeManagementUnit : :GrazingArea4\n        end\n        @rtransform begin\n            :GrazingArea1 = iszero(:GrazingArea1) ? :SizeManagementUnit : :GrazingArea1\n            :GrazingArea2 = iszero(:GrazingArea2) ? :SizeManagementUnit : :GrazingArea2\n            :GrazingArea3 = iszero(:GrazingArea3) ? :SizeManagementUnit : :GrazingArea3\n            :GrazingArea4 = iszero(:GrazingArea4) ? :SizeManagementUnit : :GrazingArea4\n        end\n        @rtransform begin\n            :inten_graz1 = :DayGrazing1 * :LivestockUnits1 / :GrazingArea1\n            :inten_graz2 = :DayGrazing2 * :LivestockUnits2 / :GrazingArea2\n            :inten_graz3 = :DayGrazing3 * :LivestockUnits3 / :GrazingArea3\n            :inten_graz4 = :DayGrazing4 * :LivestockUnits4 / :GrazingArea4\n        end\n        @rtransform :intens_total = :inten_graz1 + :inten_graz2 + :inten_graz3 + :inten_graz4\n        @rtransform begin\n            :isgrazed1 = :inten_graz1 &gt; 0.0\n            :isgrazed2 = :inten_graz2 &gt; 0.0\n            :isgrazed3 = :inten_graz3 &gt; 0.0\n            :isgrazed4 = :inten_graz4 &gt; 0.0\n        end\n\n        ## on some rows the start of the first grazing period was missing\n        ## set to the start of the start of the overall grazing period\n        @rtransform :StartGrazingPeriod1 =\n            ismissing(:StartGrazingPeriod1) ? :StartGrazing : :StartGrazingPeriod1\n\n        @rtransform begin\n            :StartGrazingPeriod1 = convert_month(:StartGrazingPeriod1)\n            :StartGrazingPeriod2 = convert_month(:StartGrazingPeriod2)\n            :StartGrazingPeriod3 = convert_month(:StartGrazingPeriod3)\n            :StartGrazingPeriod4 = convert_month(:StartGrazingPeriod4)\n        end\n\n        ## allyear grazing on dauerweide starts in january\n        @rtransform :StartGrazingPeriod1 = ismissing(:StartGrazingPeriod1) &&\n            :AllYearGrazing  && startswith(:GrazingType, \"Dauerweide\") ?\n            1 : :StartGrazingPeriod1\n\n        ## for 16 rows (one row = one year of one site) the start of grazing was missing\n        ## set to june\n        @rtransform :StartGrazingPeriod1 = ismissing(:StartGrazingPeriod1) ?\n            6 : :StartGrazingPeriod1\n\n        ## for 8 rows the start of the second grazing period was missing\n        ## set to start of first grazing period + one month\n        @rtransform :StartGrazingPeriod2 = ismissing(:StartGrazingPeriod2) &&\n            !iszero(:DayGrazing2) && !iszero(:LivestockUnits2) ?\n            :StartGrazingPeriod1 + 1 : :StartGrazingPeriod2\n\n        ## for 2 rows the start of the third grazing period was missing\n        ## set to start of second grazing period + one month (= July & November)\n        @rtransform :StartGrazingPeriod3 = ismissing(:StartGrazingPeriod3) &&\n            !iszero(:DayGrazing3) && !iszero(:LivestockUnits3) ?\n            :StartGrazingPeriod2 + 1 : :StartGrazingPeriod3\n\n        ## for 1 row the start of the fourth grazing period was missing\n        ## set to start of third grazing period + one month (= November)\n        @rtransform :StartGrazingPeriod4 = ismissing(:StartGrazingPeriod4) &&\n            !iszero(:DayGrazing4) && !iszero(:LivestockUnits4) ?\n            :StartGrazingPeriod3 + 1 : :StartGrazingPeriod4\n\n        ## set the start of the grazig to the first day of the month\n        @rtransform :start_graz1 = :isgrazed1 ?\n            Dates.Date(:Year, :StartGrazingPeriod1) : missing\n\n        ## set the end of the first grazing period to the start date + the number of days\n        @rtransform :end_graz1 = :isgrazed1 ?\n            :start_graz1 + Dates.Day(:DayGrazing1) : missing\n\n        ## if the start of the second grazing period is before the end of the first\n        ## set the start of the second to the end of the first + one day\n        @rtransform :start_graz2 = :isgrazed2 ?\n            Dates.Date(:Year, :StartGrazingPeriod2) : missing\n        @rtransform :start_graz2 = :isgrazed2 && :start_graz2 &lt;= :end_graz1 ?\n            :end_graz1 + Dates.Day(1) : :start_graz2\n\n        ## set the end of the second grazing period to the start date + the number of days\n        @rtransform :end_graz2 = :isgrazed2 ?\n            :start_graz2 + Dates.Day(:DayGrazing2) : missing\n\n        ## if the start of the third grazing period is before the end of the second\n        ## set the start of the third to the end of the second + one day\n        @rtransform :start_graz3 = :isgrazed3 ?\n            Dates.Date(:Year, :StartGrazingPeriod3) : missing\n        @rtransform :start_graz3 = :isgrazed3 && :start_graz3 &lt;= :end_graz2 ?\n            :end_graz2 + Dates.Day(1) : :start_graz3\n\n        ## set the end of the third grazing period to the start date + the number of days\n        @rtransform :end_graz3 = :isgrazed3 ?\n            :start_graz3 + Dates.Day(:DayGrazing3) : missing\n\n        ## if the start of the fourth grazing period is before the end of the third\n        ## set the start of the fourth to the end of the third + one day\n        @rtransform :start_graz4 = :isgrazed4 ?\n            Dates.Date(:Year, :StartGrazingPeriod4) : missing\n        @rtransform :start_graz4 = :isgrazed4 && :start_graz4 &lt;= :end_graz3 ?\n            :end_graz3 + Dates.Day(1) : :start_graz4\n\n        ## set the end of the fourth grazing period to the start date + the number of days\n        @rtransform :end_graz4 = :isgrazed4 ?\n            :start_graz4 + Dates.Day(:DayGrazing4) : missing\n    end\n\n    test1 = sum(abs.(df.TotalGrazing .- df.intens_total) .&gt; 10)\n    test2 = df[ismissing.(df.StartGrazingPeriod1), :]\n    test3 = df[ismissing.(df.StartGrazingPeriod2) .&& .! iszero.(df.DayGrazing2) .&&\n               .! iszero.(df.LivestockUnits2), :]\n    test4 = df[ismissing.(df.StartGrazingPeriod3) .&& .! iszero.(df.DayGrazing3) .&&\n               .! iszero.(df.LivestockUnits3), :]\n    test5 = df[ismissing.(df.StartGrazingPeriod4) .&& .! iszero.(df.DayGrazing4) .&&\n               .! iszero.(df.LivestockUnits4), :]\n\n    ## two rows have a small deviation in the total grazing intensity in my calculations\n    @show test1\n    @show nrow(test2)\n    @show nrow(test3)\n    @show nrow(test4)\n    @show nrow(test5)\n\n    display(scatter(df.TotalGrazing, df.intens_total, color = (:black, 0.2)))\n\n    ## produce the final dataframe that is used for the model input\n    final_df = @chain df begin\n        @rename begin\n            :year = :Year\n            :plotID = :EP_PlotID\n        end\n        @rtransform begin\n            :inten_graz1 = round(:inten_graz1 / :DayGrazing1; digits=3)\n            :inten_graz2 = round(:inten_graz2 / :DayGrazing2; digits=3)\n            :inten_graz3 = round(:inten_graz3 / :DayGrazing3; digits=3)\n            :inten_graz4 = round(:inten_graz4 / :DayGrazing4; digits=3)\n        end\n        @select begin\n            :plotID\n            :year\n            :inten_graz1\n            :inten_graz2\n            :inten_graz3\n            :inten_graz4\n            :start_graz1\n            :start_graz2\n            :start_graz3\n            :start_graz4\n            :end_graz1\n            :end_graz2\n            :end_graz3\n            :end_graz4\n        end\n\n    end\n\n    return final_df\nend\n\ndf_supple, df_supple_sum = supplementary_feeding(\"../data/\")\ndf = load_grazing(\"../data/\")\n\nscatter(vec(Matrix(@select(df, $(r\"inten_\")))))\n\n\nCSV.write(\"supplementary_feeding.csv\", df_supple_sum)\nCSV.write(\"grazing.csv\", df)\n\n# move file to GrasslandTraitSim/assets/data/input\n\n\nlet\n    function find_start_month(general_start, start_first_period)\n        if ! ismissing(general_start)\n            return convert_month(general_start)\n        elseif ! ismissing(start_first_period)\n            return convert_month(start_first_period)\n        else\n            return 6\n        end\n    end\n\n    function find_end_month(general_end)\n        if ! ismissing(general_end)\n            return convert_month(general_end)\n        else\n           return 10\n        end\n    end\n\n    function load_grazing_simple(path)\n        lui_df = CSV.read(\n            path * \"LUI_tool_input.csv\",\n            DataFrame)\n\n        df = CSV.read(\n            path * \"nonpublic_management_input.csv\",\n            DataFrame;\n            missingstring=[\"\", \"NA\"]);\n\n        df = mapcols(col -&gt; replace(col, \"-1\" =&gt; missing), df)\n        df = mapcols(col -&gt; replace(col, -1 =&gt; missing), df)\n        df = mapcols(col -&gt; replace(col, \"ja\" =&gt; true), df)\n        df = mapcols(col -&gt; replace(col, \"nein\" =&gt; false), df)\n\n        df = @chain df begin\n            innerjoin(@select(lui_df, :Year, :EP_PlotID, :TotalGrazing), _, on = [:Year, :EP_PlotID])\n\n            @transform :startmonth = find_start_month.(:StartGrazing, :StartGrazingPeriod1)\n            @transform :endmonth = find_end_month.(:EndGrazing)\n\n            @transform :start_graz1 = Dates.firstdayofmonth.(Dates.Date.(:Year, :startmonth))\n            @transform :end_graz1 = Dates.lastdayofmonth.(Dates.Date.(:Year, :endmonth))\n\n            @transform :days_grazing = :end_graz1 .- :start_graz1\n            @transform :inten_graz1 = :TotalGrazing ./ Dates.value.(:days_grazing)\n\n            @rtransform :start_graz1 = iszero(:TotalGrazing) ? missing : :start_graz1\n            @rtransform :end_graz1 = iszero(:TotalGrazing) ? missing : :end_graz1\n\n\n            @transform :plotID = convert_id.(:EP_PlotID)\n            @rename :year = :Year\n            @orderby :plotID\n            # @select :plotID :year :TotalGrazing :StartGrazing :EndGrazing :start_graz1 :end_graz1 :days_grazing :inten_graz1\n\n            @select :plotID :year :inten_graz1 :start_graz1 :end_graz1\n        end\n\n        df\n    end\n    df = load_grazing_simple(\"../data/\")\n    CSV.write(\"grazing.csv\", df)\nend\n\n\n\n\n\n\n\n\n\n\n\nVariable\nDescription\ndata source\n\n\n\n\nCUT_mowing\nHeight of mowing event, NaN means no mowing [m]\nVogt et al. (2024)\n\n\nLD_grazing\nGrazing intensity measured in livestock units, NaN means no grazing [LD ha⁻¹]\nVogt et al. (2024)\n\n\n\n\n\nCode\ndf_mow = @chain sim.data.input.mow begin\n    @subset startswith.(:plotID, \"H\")\n    @groupby :plotID\n    @combine :mowing = round(mean(:TotalMowing); digits = 1)\n    @orderby :plotID\nend\n\ndf_graz = @chain sim.data.input.graz begin\n    @subset startswith.(:plotID, \"H\")\n    @rtransform :graz1 = ismissing(:end_graz1 - :start_graz1) ? 0.0 : :inten_graz1 * Dates.value.(:end_graz1 - :start_graz1)\n    # @rtransform :graz2 = ismissing(:end_graz2 - :start_graz2) ? 0.0 : :inten_graz2 * Dates.value.(:end_graz2 - :start_graz2)\n    # @rtransform :graz3 = ismissing(:end_graz3 - :start_graz3) ? 0.0 : :inten_graz3 * Dates.value.(:end_graz3 - :start_graz3)\n    # @rtransform :graz4 = ismissing(:end_graz4 - :start_graz4) ? 0.0 : :inten_graz4 * Dates.value.(:end_graz4 - :start_graz4)\n    @transform :total_grazed = :graz1 #+ :graz2 + :graz3 + :graz4\n    @groupby :plotID\n    @combine :grazing = round(mean(:total_grazed); digits = 1)\n    @orderby :plotID\nend\n\n\nlet\n    fig = Figure(; size = (500, 800))\n    stem(fig[1,1], df_mow.mowing;\n         axis = (; ylabel = \"Mean number of mowing events per year [-]\",\n                   xticks = 1:5:50),\n         color = :blue)\n    stem(fig[2,1], 1:50, df_graz.grazing;\n         axis = (; xlabel = \"plotID\", ylabel = \"Mean grazing intensity per year [LD ha⁻¹ d]\",\n                   xticks = 1:5:50),\n         color = :red)\n    rowgap!(fig.layout, 1, 0)\n    fig\nend\n\n\n\n\n\n\n\n\n\n\n\n2.4 Raw time invariant site variables\nThe texture classes of Schöning, Solly, et al. (2021c) were partly collapsed: Fine_Silt, Medium_Silt, Coarse_Silt to silt and Fine_Sand, Medium_Sand, Coarse_Sand to sand.\n\n\n\n\n\n\n\n\nVariable\nDescription\nData source\n\n\n\n\nsand\nSand content [%]\nSchöning, Solly, et al. (2021c)\n\n\nsilt\nSilt content [%]\nSchöning, Solly, et al. (2021c)\n\n\nclay\nClay content [%]\nSchöning, Solly, et al. (2021c)\n\n\nrootdepth\nMean rooting depth of plants [mm, orig: cm]\nHerold, Schöning, and Schrumpf (2021)\n\n\nbulk\nBulk density [g cm⁻³]\nSchöning, Solly, et al. (2021a)\n\n\norganic\nOrganic matter content [%]\nSchöning, Solly, et al. (2021b)\n\n\ntotalN\nTotal nitrogen [g kg⁻¹]\nSchöning, Solly, et al. (2021b) Schöning, Trumbore, et al. (2021) Schöning, Klötzing, et al. (2021) Schöning (2023)\n\n\n\n\n\n\n\n\n\nDetails on loading the total nitrogen\n\n\n\n\n\nThe mean total nitrogen of the years 2011, 2014, 2017 and 2021 was calculated with the following script:\n\n\nsoilnutrients.jl\n\nimport CSV\nusing DataFrames, DataFramesMeta\nusing Statistics\n\nfunction read_minsoil(path, year)\n    @chain CSV.read(path, DataFrame; missingstring = \"NA\") begin\n        @rename :Plot = :EP_Plotid\n        @rename :explo = :Exploratory\n        @subset :Type .== \"G\"\n        @transform :Year = year\n    end\nend\n\nfunction convert_id(id)\n    a = first.(id, 3)\n    b = chop(id, head = 3, tail = 0)\n    b = lpad(b, 2, \"0\")\n    return a * b\nend\n\ndata_path = \"../data/\"\ndf_prep = vcat(\n    read_minsoil(data_path * \"soilnutrients_2011.csv\", 2011),\n    read_minsoil(data_path * \"soilnutrients_2014.csv\", 2014),\n    read_minsoil(data_path * \"soilnutrients_2017.csv\", 2017),\n    read_minsoil(data_path * \"soilnutrients_2021.csv\", 2021))\n\nminsoil_df = @chain df_prep begin\n    @transform :plotID = convert_id.(:Plot)\n    @orderby :plotID\n    groupby(:plotID)\n    @combine :totalN = round(mean(:Total_N); digits = 2)\nend\n\nCSV.write(\"soilnutrients.csv\", minsoil_df)\n\n\n## visualize how the total N changes over time\nusing AlgebraOfGraphics, CairoMakie\nlet\n    plots = [\"$(explo)$(lpad(i, 2, \"0\"))\" for i in 1:5 for explo in [\"HEG\"]]\n\n    df = @chain df_prep begin\n        @transform :plotID = convert_id.(:Plot)\n        @orderby :plotID\n        @subset :plotID .∈ Ref(plots)\n        @select :plotID :Year :Total_N\n   end\n\n   xy = data(df) * mapping(:Year, :Total_N, color = :plotID)\n   layers = visual(Scatter) + visual(Lines)\n   draw(layers * xy)\nend\n\n\n\n\n\n\n\n\n\n\nDetails on loading the soil characteristics for WHC and PWP\n\n\n\n\n\nSoil characteristics were loaded with the following script:\n\n\nsoilwater.jl\n\nimport CSV\nusing DataFrames, DataFramesMeta\nusing Statistics\nusing Unitful\n\nfunction convert_id(id)\n    a = first.(id, 3)\n    b = chop(id, head = 3, tail = 0)\n    b = lpad(b, 2, \"0\")\n    return a * b\nend\n\n\ndata_dir = \"../data/\"\n\ntexture_df = CSV.read(data_dir * \"soiltexture_2011.csv\",\n    DataFrame;\n    missingstring = [\"NA\"])\n\norganic_df = CSV.read(data_dir * \"soilorganicmatter_2011.csv\",\n    DataFrame;\n    missingstring = [\"NA\"])\n\nbulk_df = CSV.read(data_dir * \"soilbulkdensity_2011.csv\",\n    DataFrame;\n    missingstring = [\"-888888\", \"NA\"])\ncoalesce(bulk_df, NaN, missing)\n\nrooting_df = CSV.read(data_dir * \"rootingdepth_2008.csv\",\n    DataFrame;\n    missingstring = [\"NA\"])\n\nplot_rooting_df = @chain rooting_df begin\n    @rename :EP_Plotid = :plotid\n    @subset .!ismissing.(:rootingSpace)\n    groupby(_, :EP_Plotid)\n    @combine :root_depth = median(:rootingSpace)\nend\n\nexplo_rooting_df = @chain rooting_df begin\n    @rename :EP_Plotid = :plotid\n    @transform :explo = string.(first.(:EP_Plotid))\n    @subset .!ismissing.(:rootingSpace)\n    groupby(_, :explo)\n    @combine :median_root_depth = median(:rootingSpace)\nend\n\ndf = @chain texture_df begin\n    @subset :Type .== \"G\"\n    @transform :Clay = :Clay / 10\n    @transform :Silt = (:Fine_Silt + :Medium_Silt + :Coarse_Silt) / 10\n    @transform :Sand = (:Fine_Sand + :Medium_Sand + :Coarse_Sand) / 10\n    @rename :explo = :Exploratory\n    leftjoin(_, organic_df, on = :EP_Plotid, makeunique = true)\n    leftjoin(_, bulk_df, on = :EP_Plotid, makeunique = true)\n    leftjoin(_, plot_rooting_df, on = :EP_Plotid, makeunique = true)\n    leftjoin(_, explo_rooting_df, on = :explo)\n    @rename :bulk = :BD\n    @transform :bulk = coalesce.(:bulk, mean(:bulk[.!ismissing.(:bulk)]))\n    @transform :root_depth = coalesce.(:root_depth, :median_root_depth) * 10\n    @transform :organic = round.(:Organic_C / 1000 * 100; digits = 2)\n    @rtransform :plotID = convert_id(:EP_Plotid)\n    @orderby :plotID\n    @rename begin\n        :clay = :Clay\n        :silt = :Silt\n        :sand = :Sand\n        :rootdepth = :root_depth\n    end\n    @select :plotID :explo :clay :silt :sand :organic :bulk :rootdepth\nend\n\nCSV.write(\"soilwater.csv\", df)\n\n\n\n\n\n\n2.5 Water holding capacity and permanent wilting point\nThe procedure for converting soil characteristics to water holding capacity (WHC) and permanent wilting point (PWP) is described by Gupta and Larson (1979). These plots show the usable field capacity (uFC), water holding capacity (WHC) and permanent wilting point (PWP) for all sites of the Hainich exploratory.\n\n\nCode\nimport GrasslandTraitSim as sim\nimport CSV\nusing DataFrames, DataFramesMeta\nusing CairoMakie\nusing AlgebraOfGraphics\n\ndf = CSV.read(sim.assetpath() * \"/data/input/soilwater.csv\", DataFrame) \n\n### Estimating Generalized Soil-water Characteristics from Texture\n## Gupta 1979\nm = [-0.04 7.053 10.242 10.070 6.333 -32.120 0.950\n    -0.07 5.678 9.228 9.135 6.103 -26.960 0.959\n    -0.10 5.018 8.548 8.833 4.966 -24.230 0.961\n    -0.20 3.890 7.066 8.408 2.817 -18.780 0.962\n    -0.33 3.075 5.886 8.039 2.208 -14.340 0.962\n    -0.60 2.181 4.557 7.557 2.191 -9.276 0.964\n    -1.0 1.563 3.620 7.154 2.388 -5.759 0.966\n    -2.0 0.932 2.643 6.636 2.717 -2.214 0.967\n    -4.0 0.483 1.943 6.128 2.925 -0.204 0.962\n    -7.0 0.214 1.538 5.908 2.855 1.530 0.954\n    -10.0 0.076 1.334 5.802 2.653 2.145 0.951\n    -15.0 -0.059 1.142 5.766 2.228 2.671 0.947]\n\ngupta_df = DataFrame(m, [:Ψ_bar, :a, :b, :c, :d, :e, :R])\ngupta_df = @chain gupta_df begin\n    @transform :a = :a * 1e-3\n    @transform :b = :b * 1e-3\n    @transform :c = :c * 1e-3\n    @transform :d = :d * 1e-3\n    @transform :e = :e * 1e-2\n    @transform :Ψ_hPa = :Ψ_bar * 1000\n    @rtransform :pF = log10(abs(:Ψ_hPa))\n    @select :pF :Ψ_hPa :Ψ_bar :a :b :c :d :e\nend\n\n@subset gupta_df :Ψ_hPa .== -15000\n\n\nfunction calc_gupta(; sand, silt, clay, organic, bulk)\n    ps = NamedTuple.(eachrow(gupta_df))\n    θs = fill(NaN, nrow(gupta_df))\n\n    for i in 1:nrow(gupta_df)\n        p = ps[i]\n        θ = p.a * sand + p.b * silt + p.c * clay + p.d * organic + p.e * bulk\n        θs[i] = θ\n    end\n\n    θs[θs .&gt; 1] .= 1\n    θs[θs .&lt; 0] .= 0\n\n    return θs\nend\n\nfunction calc_specific(; df, hPA)\n    gupta_sub = @chain gupta_df begin\n        @subset :Ψ_hPa .== hPA\n        @select $(Not(r\"pF|Ψ\"))\n    end\n    p = NamedTuple.(eachrow(gupta_sub))[1]\n    θ = p.a * df.sand + p.b * df.silt + p.c * df.clay + p.d * df.organic + p.e * df.bulk\n\n    return θ .* df.rootdepth\nend\n\ndf.WHC = calc_specific(; df, hPA = -70)\ndf.PWP = calc_specific(; df, hPA = -15000)\ndf.uFC = df.WHC - df.PWP\n@subset! df :explo .== \"H\"\n\nlet\n    fig = Figure(; size = (800, 300))\n    ax1, _ = hist(fig[1,1], df.WHC, axis = (; xlabel = \"Water holding capacity [mm]\"))\n    ax2, _ = hist(fig[1,2], df.PWP, axis = (; xlabel = \"Permanent wilting point [mm]\", yticklabelsvisible = false))\n    ax3, _ = hist(fig[1,3], df.uFC, axis = (; xlabel = \"Usable field capacity [mm]\", yticklabelsvisible = false))\n    linkyaxes!(ax1, ax2, ax3)\n    colgap!(fig.layout, 1, 0)\n    colgap!(fig.layout, 2, 0)\n    fig\nend",
    "crumbs": [
      "Data of the Biodiversity Exploratories"
    ]
  },
  {
    "objectID": "data.html#calibration-data",
    "href": "data.html#calibration-data",
    "title": "Data of the Biodiversity Exploratories",
    "section": "3 Calibration data",
    "text": "3 Calibration data\n\n3.1 Biomass and vegetation height\nBiomass and vegetation height were measured in the Biodiversity Exploratories once per year. The data was downloaded from BExIS and processed to get the measured biomass and vegetation height.\n\n\n\n\n\n\n\n\nVariable\nDescription\nData source\n\n\n\n\nbiomass[plot, year]\nDried aboveground biomass, cut at a height of 4 cm once per year in spring [g m⁻²]\nBoch et al. (2017) Schmitt, Prati, and Fischer (2017) Schmitt et al. (2018) Schmitt and Fischer (2018) Schmitt, Prati, and Fischer (2018b) Fischer, Hinderling, Schäfer, et al. (2023a) Fischer, Hinderling, Schäfer, et al. (2023b) Fischer, Schäfer, et al. (2023) Schäfer, Prati, and Fischer (2023) Bolliger, Hinderling, et al. (2023) Fischer, Hinderling, Bolliger, et al. (2023) Bolliger, Prati, et al. (2023) Prati and Bolliger (2023) Prati (2023)\n\n\nheight[plot, t]\nMeasured vegetation height\nsame as above\n\n\n\n\n\n\n\n\n\nDetails on getting the measured biomass\n\n\n\n\n\nThe measured (cut) biomass data was processed with the following script:\nimport CSV, Dates\nusing DataFrames, DataFramesMeta\nusing Statistics\n\nfunction convert_id(id)\n    a = first.(id, 3)\n    b = chop(id, head = 3, tail = 0)\n    b = lpad(b, 2, \"0\")\n    return a * b\nend\n\nfunction core_biomass(path)\n    datasets1 = [\"biomass_$y.csv\" for y in 2009:2011]\n    datasets2 = [\"vegetation_header_data_$y.csv\" for y in 2012:2022]\n    datasets = vcat(datasets1, datasets2)\n\n    id_cols = [\n        :GpPlotID\n        :PlotID\n        fill(:EpPlotID, 7)...\n        fill(:Ep_PlotID, 4)...\n        \"EP.PlotID\"\n    ]\n    date_cols = [\n        :date_new\n        :Datum\n        fill(:date, 3)...\n        fill(:date_new, 4)...\n        fill(:date_bm, 4)...\n        \"date.bm\"\n    ]\n    biomass_cols = [\n        [:Biomass, :biomass_missing],\n        [:Biomasse, :biomass_missing],\n        fill([:biomass_g, :biomass_missing], 10)...,\n        [:biomass_g_1, :biomass_g_2],\n        [\"biomass.1\", \"biomass.2\"]\n    ]\n\n    dfs = []\n    for i in eachindex(datasets)\n        df = CSV.read(path * datasets[i], DataFrame;\n            missingstring = [\"\", \"NA\"])\n\n        if !any([\"Datum\", \"date\", \"date_bm\", \"date.bm\"] .∈ Ref(names(df)))\n            if \"year\" ∈ names(df)\n                doy = df.day_of_year\n                df.day_of_year[ismissing.(doy)] .= round(median(doy[.!ismissing.(doy)]))\n                df.date_new = Dates.Date.(df.year) + Dates.Day.(df.day_of_year)\n            elseif \"Year\" ∈ names(df)\n                doy = df.Day_of_year\n                year = df.Year\n                df.date_new = Dates.Date.(year) + Dates.Day.(doy)\n            end\n        end\n\n        df = @chain df begin\n            @transform :plotID = convert_id.($(id_cols[i]))\n            @rename :date = $(date_cols[i])\n\n            ## extract and convert from g/m2 to kg/ha\n            @transform :biomass_missing = NaN\n            @transform :biomass1 = round.($(biomass_cols[i][1]) * 10)\n            @transform :biomass2 = round.($(biomass_cols[i][2]) * 10)\n            @transform :cutting_height = 0.04\n\n            @orderby :date\n            @select :plotID :date :biomass1 :biomass2 :cutting_height\n        end\n\n        unique!(df, [:plotID, :date])\n\n        push!(dfs, df)\n    end\n\n    concat_dfs = vcat(dfs...)\n\n    final_df = @chain stack(concat_dfs, [:biomass1, :biomass2]) begin\n        @rsubset !isnan(:value) & !ismissing(:date)\n        @rename :biomass = :value\n        @transform :stat = \"core\"\n        @select :plotID :date :biomass :cutting_height :stat\n    end\n\n    return final_df\nend\n\nfunction sade_biomass(path)\n    datasets = [\"biomass_$(y)_sade.csv\" for y in [2015, 2017]]\n\n    dfs = []\n    for i in eachindex(datasets)\n        df = CSV.read(path * datasets[i], DataFrame;\n                    missingstring = [\"\", \"NA\"])\n\n        df_transformed = @chain df begin\n            @subset :treatment .== \"control\"\n            @transform begin\n                :plotID = convert_id.(:EpPlotID)\n                :date = Dates.Date.(:year) + Dates.Day.(:day_of_year_bm)\n                :biomass = round.(:biomass_g .* 10)\n                :cutting_height = 0.02\n            end\n            @select :plotID :date :biomass :cutting_height\n        end\n        push!(dfs, df_transformed)\n    end\n\n    final_df = vcat(dfs...)\n    @transform! final_df :stat = \"sade\"\n    return final_df\nend\n\nfunction hedgeII_biomass(path)\n    datasets = [\n        \"biomass_2017_hainich_hedgeII.csv\", # Hainich 2017\n        \"biomass_2018_alb_hedgeII.csv\"  # Alb 2018\n    ]\n    dates = [\n        Dates.Date(2017, 05, 31),\n        Dates.Date(2018, 05, 31)\n    ]\n\n    dfs = []\n    for i in eachindex(datasets)\n        df = CSV.read(path * datasets[i], DataFrame;\n                    missingstring = [\"\", \"NA\"])\n        df_transformed = @chain df begin\n            @transform begin\n                :date = dates[i]\n                :biomass = round.(:biomass .* 250)\n                :plotID = :plotname\n                :cutting_height = 0.02\n            end\n            @rsubset !ismissing(:biomass)\n            @select :plotID :date :biomass :cutting_height\n        end\n\n        disallowmissing!(df_transformed)\n\n        push!(dfs, df_transformed)\n    end\n\n    final_df = vcat(dfs...)\n    @transform! final_df :stat = \"hedgeII\"\n    return final_df\nend\n\nfunction sat_biomass(path)\n    df = CSV.read(path * \"biomass_from_sentinel.csv\", DataFrame)\n    @rename! df begin\n        :satellite_mean = :biomass_kg_ha\n        :satellite_min = :biomass_kg_ha_min\n        :satellite_max = :biomass_kg_ha_max\n    end\n\n    df_stack = stack(df, [:satellite_mean, :satellite_min, :satellite_max];\n                     variable_name = :stat, value_name = :biomass)\n\n    df_final = @chain df_stack begin\n        @transform :cutting_height = 0.04\n        @select :plotID :date :biomass :cutting_height :stat\n    end\n    return df_final\nend\n\n\nlet\n    data_path = \"../data/\"\n\n    df = vcat(core_biomass(data_path), sade_biomass(data_path),\n              sat_biomass(data_path), hedgeII_biomass(data_path))\n    df = @orderby df :plotID :date\n    disallowmissing!(df)\n\n    biomass_file = \"measured_biomass.csv\"\n\n    # @info \"$biomass_file\"\n    CSV.write(biomass_file, df)\n    df\nend\n\n\n\n\n\n\n\n\n\nDetails on getting the measured vegetation height\n\n\n\n\n\nThe measured vegetation height data was processed with the following script:\nimport CSV, Dates\nusing DataFrames, DataFramesMeta\nusing Statistics\n\nfunction convert_id(id)\n    a = first.(id, 3)\n    b = chop(id, head = 3, tail = 0)\n    b = lpad(b, 2, \"0\")\n    return a * b\nend\n\nfunction core_height(path)\n    datasets = [\n        \"vegetation_2012.csv\"\n        \"biomass_2013.csv\"\n        \"biomass_2014.csv\"\n        \"vegetation_2015.csv\"\n        \"biomass_2016.csv\"\n        \"biomass_2017.csv\"\n        \"biomass_2018.csv\"\n        \"biomass_2019.csv\"\n        \"biomass_2020.csv\"\n        \"biomass_2021.csv\"\n        \"biomass_2022.csv\"\n    ]\n\n    id_cols = [\n        fill(:EpPlotID, 6)...\n        fill(:Ep_PlotID, 4)...\n        \"EP.PlotID\"\n    ]\n    date_cols = [\n        fill(:date, 2)...\n        fill(:date_new, 4)...\n        fill(:date_bm, 4)...\n        \"date.bm\"\n    ]\n\n    veg_height = [\n        fill([:v_height_1_cm, :v_height_2_cm,\n              :v_height_3_cm, :v_height_4_cm], 2)...,\n        fill([:vegetation_height_mean_cm, :height_missing,\n              :height_missing, :height_missing], 7)...,\n        [:vegetation_height_mean_cm_1, :vegetation_height_mean_cm_2,\n         :height_missing, :height_missing],\n        [\"vegetation.height.1\", \"vegetation.height.2\", :height_missing, :height_missing]\n    ]\n\n    dfs = []\n    for i in eachindex(datasets)\n        df = CSV.read(path * datasets[i], DataFrame;\n            missingstring = [\"\", \"NA\"])\n\n        if !any([\"Datum\", \"date\", \"date_bm\", \"date.bm\"] .∈ Ref(names(df)))\n            if \"year\" ∈ names(df)\n                doy = df.day_of_year\n                df.day_of_year[ismissing.(doy)] .= round(median(doy[.!ismissing.(doy)]))\n                df.date_new = Dates.Date.(df.year) + Dates.Day.(df.day_of_year)\n            elseif \"Year\" ∈ names(df)\n                doy = df.Day_of_year\n                year = df.Year\n                df.date_new = Dates.Date.(year) + Dates.Day.(doy)\n            end\n        end\n\n        df[!, :height_missing] .= NaN\n\n        df = @chain df begin\n            @transform begin\n                :plotID = convert_id.($(id_cols[i]))\n                :height1 = $(veg_height[i][1])\n                :height2 = $(veg_height[i][2])\n                :height3 = $(veg_height[i][3])\n                :height4 = $(veg_height[i][4])\n            end\n            @rename :date = $(date_cols[i])\n            @orderby :date\n            @select :plotID :date :height1 :height2 :height3 :height4\n        end\n\n        unique!(df, [:plotID, :date])\n\n        push!(dfs, df)\n    end\n\n    concat_dfs = vcat(dfs...)\n\n    final_df = @chain stack(concat_dfs, [:height1, :height2, :height3, :height4]) begin\n        @rsubset !isnan(:value) & !ismissing(:date)\n        @transform :height = round.(:value ./ 100; digits = 3)\n        @orderby :plotID :date\n        @select :plotID :date :height\n    end\n\n    disallowmissing!(final_df)\n\n    return final_df\nend\n\n\nlet\n    path = \"../data/\"\n    df = core_height(path)\n    output_path = \"measured_height.csv\"\n\n    # move to assets/data/validation\n    CSV.write(output_path, df)\n    df\nend\n\n\n\n\n\n3.2 Community weighted mean traits\nVegetation data was subsetted to 2009 - 2002. The exact date of the vegetation records is not available in Hinderling and Keller (2023), therefore the dates of the vegetation sampling were used from the header data sets.\nSpecies mean trait values were calculated from the raw trait data sets.\n\n\n\n\n\n\nDetails on calculating the community weighted mean traits\n\n\n\n\n\nThe community weighted mean traits were calculated with the following script:\n\n\n2_cwm_traits.jl\n\ninclude(\"0_functions_load_traits.jl\")\n\n##### load tables\ndata_path = \"../data/\"\ncwm_output_path = \"cwm_traits.csv\"\nveg_df, veg_species_df = load_veg_df(data_path)\ndf_leaf = bexis_leaf_traits(data_path)\ndf_root = bexis_root_traits(data_path)\ndf_try = load_lnc_try(data_path)\ndf_maxheight = CSV.read(data_path * \"maxheight_rothmaler.csv\", DataFrame)\n@transform! df_maxheight :maxheight = :maxheight .* u\"m\"\n@select! df_maxheight :species :maxheight\n\n##### create trait tables for all species in vegetation dataset\ndf_bexis = @chain outerjoin(df_leaf, df_root, on = :species, makeunique = true) begin\n    @rtransform :sla = uconvert(u\"m^2 / g\", mean_missing(:sla1, :sla2))\n    @select $(Not([:sla1, :sla2, :LA, :LDM, :leaf_species_orig, :root_species_orig]))\nend\n\nveg_trait_df = @chain veg_species_df begin\n    leftjoin(df_bexis; on = :species)\n    leftjoin(df_maxheight; on = :species)\n    leftjoin(df_try; on = :species)\n    @rsubset :maxheight &lt;= 2.0u\"m\"\n    @orderby :species\nend\n\nveg_trait_final_df = @chain veg_trait_df begin\n    @transform :species = :veg_orig_name\n    @select $(Not(:veg_orig_name))\nend\n\n######### join trait and species cover data\nfunction cwm_missing(trait_vals, cover_vals)\n    f = .! ismissing.(trait_vals)\n    sum(cover_vals[f] .* trait_vals[f] ./ sum(cover_vals[f]))\nend\n\nfunction cwm_quality(trait_vals, cover_vals)\n    f = .! ismissing.(trait_vals)\n    sum(cover_vals .* f ./ sum(cover_vals))\nend\n\nfunction functional_dispersion(trait_vec, cover_vals;)\n    # Laliberté & Legendre 2010\n\n    trait_matrix = hcat(trait_vec...)\n    traits_missing = ismissing.(trait_matrix)\n    species_filter = iszero.(vec(sum(traits_missing; dims = 2)))\n\n    trait_matrix = trait_matrix[species_filter, :]\n    cover_vals = cover_vals[species_filter]\n\n    nspecies, ntraits = size(trait_matrix)\n    z_squarred = zeros(nspecies)\n\n    for t in 1:ntraits\n        trait_vals = trait_matrix[:, t]\n        trait_vals = trait_vals ./ mean(trait_vals)\n\n        cwm = sum(cover_vals .* trait_vals ./ sum(cover_vals))\n        z_squarred .+= (trait_vals .- cwm) .^ 2\n    end\n\n    z = sqrt.(z_squarred)\n\n    relative_cover = cover_vals ./ sum(cover_vals)\n    return sum(z .* relative_cover)\nend\n\ncwm_veg_df = @chain veg_df begin\n    leftjoin(veg_trait_final_df, on = :species)\n    @groupby :plotID :year\n    @combine begin\n        :rsa = cwm_missing(:srsa, :cover)\n        :amc = cwm_missing(:amc, :cover)\n        :abp = cwm_missing(:abp, :cover)\n        :sla = cwm_missing(:sla, :cover)\n        :maxheight = cwm_missing(:maxheight, :cover)\n        :lnc = cwm_missing(:lnc, :cover)\n        :fdis = functional_dispersion([:srsa, :amc, :abp, :sla, :maxheight, :lnc], :cover) #\n        # :srsa_quality = cwm_quality(:srsa, :cover)\n        # :amc_quality = cwm_quality(:amc, :cover)\n        # :abp_quality = cwm_quality(:abp, :cover)\n        # :sla_quality = cwm_quality(:sla, :cover)\n        # :height_quality = cwm_quality(:height, :cover)\n        # :lnc_quality = cwm_quality(:lnc, :cover)\n    end\n    @orderby :plotID :year\nend\n\n##### join vegetation date\nveg_date_df = load_vegetation_date_df(data_path)\n\ncwm_veg_df = @chain cwm_veg_df begin\n    @subset 2009 .&lt;= :year .&lt;= 2021\n    leftjoin(veg_date_df, on = [:year, :plotID])\nend\ndisallowmissing!(cwm_veg_df)\n\n\n##### write output without units\ncwm_veg_wo_units_df = @rtransform cwm_veg_df begin\n    :rsa = ustrip(:rsa)\n    :sla = ustrip(:sla)\n    :maxheight = ustrip(:maxheight)\n    :lnc = ustrip(:lnc)\nend\nCSV.write(cwm_output_path, cwm_veg_wo_units_df)\n\n##### read file and add units\n@chain CSV.read(cwm_output_path, DataFrame) begin\n    @transform begin\n        :srsa = :srsa * u\"m^2 / g\"\n        :sla = :sla * u\"m^2 / g\"\n        :height = :height * u\"m\"\n        :lnc = :lnc * u\"mg / g\"\n    end\nend\n\nThe functions for loading the trait data are described in the following script:\n\n\n0_functions_load_traits.jl\n\nusing DataFrames, DataFramesMeta\nusing Unitful\nusing Statistics\nusing RCall\nimport CSV\nimport Dates\n\nfunction mean_missing(x1, x2)\n    if ismissing(x1)\n        return x2\n    elseif ismissing(x2)\n        return x1\n    else\n        return mean([x1, x2])\n    end\nend\n\nfunction bexis_leaf_traits(path)\n    @info \"Loading bexis leaf traits\"\n    df = CSV.read(path * \"leaf_traits.csv\", DataFrame;\n        missingstring=\"NA\")\n\n    # LA: leaf area [mm²]\n    # LFM: leaf fresh mass [g]\n    # LDM: leaf dry weight [g]\n    df = @chain df begin\n        @subset :system .== \"grassland\"\n        @rtransform begin\n            :LA = :total_area * u\"mm^2\"\n            :LDM = :dry_weight * u\"g\"\n            :leaf_species_orig = :pl_species\n            :leaf_species = :pl_species\n        end\n        @rename :plotID = :plotid_withzero\n        @subset :leaf_species .∉ Ref([\"Crataegus sp\", \"Secale sp\"])\n        @select :plotID :leaf_species :leaf_species_orig :LA :LDM\n        @rsubset !(ismissing(:LA) || ismissing(:LDM))\n    end\n    disallowmissing!(df)\n\n    df[df.leaf_species .== \"Festuca pratensis\", :leaf_species] .= \"Lolium pratense (Huds.) Darbysh.\"\n    df[df.leaf_species .== \"Festuca arundinacea\", :leaf_species] .= \"Lolium arundinaceum (Schreb.) Darbysh.\"\n    df[df.leaf_species .== \"Taraxacum sp\", :leaf_species] .= \"Taraxacum officinale F.H.Wigg.\"\n    df[df.leaf_species .== \"Prunella sp\", :leaf_species] .= \"Prunella vulgaris L.\"\n    df[df.leaf_species .== \"Primula elatior veris agg\", :leaf_species] .= \"Primula elatior Hill\"\n    df[df.leaf_species .== \"Bromus hordeaceus agg incl. B. commutatus\", :leaf_species] .= \"Bromus hordeaceus L.\"\n    df[df.leaf_species .== \"Rhinanthus agg\", :leaf_species] .= \"Rhinanthus minor L.\"\n\n    leaf_species = sort(unique(df.leaf_species))\n    # [println(s) for s in sort(unique(leaf_species))];\n    @rput leaf_species\n    R\"\"\"\n    library(TNRS)\n    leaf_species_df&lt;- TNRS(leaf_species)\n    NaN\n    \"\"\"\n    @rget leaf_species_df\n\n    leaf_species_df = @chain leaf_species_df begin\n        @rename begin\n            :leaf_species = :Name_submitted\n            :species = :Accepted_species\n        end\n        @select :species :leaf_species\n    end\n\n    @chain df begin\n        leftjoin(leaf_species_df, on = :leaf_species)\n        @groupby :species\n        @combine begin\n            :leaf_species_orig = first(:leaf_species_orig)\n            :LA = median(:LA)\n            :LDM = median(:LDM)\n        end\n        @orderby :species\n        @transform :sla1 = :LA ./ :LDM\n    end\nend\n\nfunction bexis_root_traits(path)\n    @info \"Loading bexis root traits\"\n    df = CSV.read(data_path * \"root_traits.csv\", DataFrame;\n        missingstring=\"NA\")\n\n    df = @chain df begin\n        @rename :root_species_orig = :species\n        @transform :species = convert.(String, :root_species_orig)\n    end\n\n    df[df.species .== \"Festuca_pratensis\", :species] .= \"Lolium pratense (Huds.) Darbysh.\"\n    df[df.species .== \"Festuca_arundinacea\", :species] .= \"Lolium arundinaceum (Schreb.) Darbysh.\"\n\n    root_species = df.species\n    # [println(s) for s in root_species];\n    @rput root_species\n    R\"\"\"\n    library(TNRS)\n    root_species_df&lt;- TNRS(root_species)\n    NaN\n    \"\"\"\n    @rget root_species_df\n\n    # BA:\n    #   below ground dry biomass / aboveground dry biomass\n    #   [ratio area/mass]\n    # SRSA:\n    #   root surface area / root dry biomass\n    #   [m²/g]\n    # AMC:\n    #   arbuscular mycorrhizal colonisation of the entire root system\n    #   [fraction, 0 to 1]\n    @chain df begin\n        @transform begin\n            :species = root_species_df.Accepted_species\n            :ba = :biomass_allocation\n            :srsa = :SRSA * u\"m^2 / g\"\n            :amc = :col\n            :sla2 = :SLA * u\"cm^2 / g\"\n        end\n        @rtransform :abp = 1 / (1 + :ba)\n        @rtransform :bbp = 1 - :abp\n        @orderby :species\n        @select :species :root_species_orig :srsa :amc :sla2 :abp :bbp\n    end\nend\n\nfunction LEDA_height(path)\n    if isfile(path *  \"canopy_height_LEDA.csv\")\n        df = CSV.read(path *  \"canopy_height_LEDA.csv\", DataFrame)\n        @transform! df :height = :height * u\"m\"\n        @subset! df .! ismissing.(:species)\n        return df\n    end\n\n    @info \"Loading leada height\"\n    function data_available(data)\n        f = isa.(data, Number)\n        f[f] .= .! isnan.(data[f]) .&& Inf .&gt; data[f] .&gt; 0\n        return f\n    end\n\n    df = CSV.read(path *  \"LEDA/canopy_height.txt\", DataFrame;\n        missingstring=[\"\", \"NA\"],\n        delim=\";\")\n\n    df[!, :height] .= NaN\n\n    ### Use single values\n    f1 = data_available(df[:, \"single value [m]\"])\n    df[f1, :height] .= df[f1, \"single value [m]\"]\n\n    ### even better mean values\n    f1 = data_available(df[:, \"mean CH [m]\"])\n    df[f1, :height] .= df[f1, \"mean CH [m]\"]\n\n    @rename! df :species_leda = $(Symbol(\"SBS name\"))\n    @transform! df :leda_species_orig = :species_leda\n\n    df[df.species_leda .== \"Festuca pratensis\", :species_leda] .= \"Lolium pratense (Huds.) Darbysh.\"\n    df[df.species_leda .== \"Festuca pratensis s. apennina\", :species_leda] .= \"Festuca pratensis subsp. apennina(De Not.) Hegi\"\n    df[df.species_leda .== \"Festuca arundinacea\", :species_leda] .= \"Lolium arundinaceum (Schreb.) Darbysh.\"\n    df[df.species_leda .== \"Senecio jacobaea\", :species_leda] .= \"Senecio vulgaris L.\"\n    df[df.species_leda .== \"Taraxacum Sec. Ruderalia\", :species_leda] .= \"Taraxacum officinale F.H.Wigg.\"\n\n    leda_species = sort(unique(df.species_leda))\n    @rput leda_species\n    R\"\"\"\n    library(TNRS)\n    leda_species_df &lt;- TNRS(leda_species)\n    NaN\n    \"\"\"\n    @rget leda_species_df\n\n    leda_species_df = @chain leda_species_df begin\n        @rename begin\n            :species_leda = :Name_submitted\n            :species = :Accepted_species\n        end\n        @select :species :species_leda\n    end\n\n    df = @chain df begin\n        leftjoin(leda_species_df, on = :species_leda)\n        @groupby :species\n        @combine begin\n            :species_leda = first(:species_leda)\n            :height = median(:height)\n        end\n    end\n\n    CSV.write(path *  \"LEDA/canopy_height_sub.csv\", df)\n    @transform! df :height = :height * u\"m\"\n\n    return df\nend\n\nfunction manual_height!(df)\n    species_without_height = [\"Poa trivialis\", \"Helictotrichon pubescens\",\n        \"Veronica teucrium\", \"Tripleurospermum inodorum\", \"Rumex acetosella\",\n        \"Medicago falcata\", \"Carex vulpina\"]\n    new_height = [0.3, 0.6, 0.5, 0.5, 0.2, 0.5, 0.7]u\"m\"\n\n    for i in eachindex(new_height)\n        s = species_without_height[i]\n        v = new_height[i]\n        df[df.species .== s, :height] .= v\n    end\n\n    return df\nend\n\nfunction load_lnc_try(path)\n    @info \"Loading try lnc\"\n\n    if isfile(path *  \"Leaf_nitrogen_content_TRY.csv\")\n        df = CSV.read(path *  \"Leaf_nitrogen_content_TRY.csv\", DataFrame)\n        @transform! df :lnc = :lnc * u\"mg/g\"\n        @subset! df .! ismissing.(:species)\n        return df\n    end\n\n    try_df = CSV.read(path *  \"TRY/33838.txt\", DataFrame;\n        missingstring=[\"\", \"NA\"],\n        delim=\"\\t\")\n\n    try_sub_df = @chain try_df begin\n        @subset .! ismissing.(:AccSpeciesName)\n        @subset .! ismissing.(:TraitName)\n        @subset .! ismissing.(:StdValue)\n        @select :AccSpeciesName :StdValue :TraitName\n    end\n    disallowmissing!(try_sub_df)\n\n    try_species = unique(try_sub_df.AccSpeciesName)\n    @rput try_species\n    R\"\"\"\n    library(TNRS)\n    try_species_df&lt;- TNRS(try_species)\n    NaN\n    \"\"\"\n    @rget try_species_df\n\n    try_species_sub_df = @chain try_species_df begin\n        @rename begin\n            :AccSpeciesName = :Name_submitted\n            :species = :Accepted_species\n        end\n        @orderby :species\n        @select :species :AccSpeciesName\n    end\n\n    df = @chain try_sub_df begin\n        leftjoin(try_species_sub_df, on = \"AccSpeciesName\")\n        @subset :TraitName .== \"Leaf nitrogen (N) content per leaf dry mass\"\n        @groupby :species\n        @combine :lnc = median(:StdValue)\n        @subset .! ismissing.(:species)\n    end\n\n    CSV.write(path *  \"TRY/33838_sub.csv\", df)\n    @transform! df :lnc = :lnc * u\"mg/g\"\n\n    return df\nend\n\n### export citation from TRY\nfunction try_dataset_references(species)\n    try_df = CSV.read(data_path *  \"TRY/33838.txt\", DataFrame;\n                    missingstring=[\"\", \"NA\"], delim=\"\\t\")\n\n    @chain try_df begin\n        @transform :species = :SpeciesName\n        @subset :species .∈ Ref(species)\n        @subset :TraitName .== \"Leaf nitrogen (N) content per leaf dry mass\"\n        @groupby :Dataset :Reference\n        @combine begin\n            :n = length(:Dataset)\n            :r = first(:Reference)\n        end\n        @orderby :n\n    end\nend\n\nfunction convert_id(id)\n    a = first.(id, 3)\n    b = chop(id, head = 3, tail = 0)\n    b = lpad(b, 2, \"0\")\n    return a * b\nend\n\nfunction to_numeric(d::Dates.Date)\n    daysinyear = Dates.daysinyear(Dates.year(d))\n    return Dates.year(d) + (Dates.dayofyear(d) - 1) / daysinyear\nend\n\nfunction load_veg_df(path)\n    veg_df = CSV.read(path * \"vegetation_2008_2022.csv\", DataFrame,\n        missingstring = [\"\", \"NA\"])\n\n    veg_df = @chain veg_df begin\n        @subset .! ismissing.(:Cover)\n        @subset :Cover .&gt; 0\n\n        @rename begin\n            :species = :Species\n            :year = :Year\n            :cover = :Cover\n            :plotID = :Useful_EP_PlotID\n        end\n        @select :plotID :year :species :cover\n        @orderby :plotID :year :species\n    end\n\n    veg_df[veg_df.species .== \"Festuca_pratensis\", :species] .= \"Lolium pratense (Huds.) Darbysh.\"\n    veg_df[veg_df.species .== \"Festuca_arundinacea\", :species] .= \"Lolium arundinaceum (Schreb.) Darbysh.\"\n    veg_df[veg_df.species .== \"Senecio_jacobaea\", :species] .= \"Jacobaea vulgaris Gaertn.\"\n    veg_df[veg_df.species .== \"Trifolium_campestre/dubium_aggr.\", :species] .= \"Trifolium dubium Sibth.\"\n    veg_df[veg_df.species .== \"Vicia_cf_lathyroides\", :species] .= \"Vicia lathyroides L.\"\n    veg_df[veg_df.species .== \"Geum_rivale/urbanum_aggr.\", :species] .= \"Geum urbanum L.\"\n    veg_df[veg_df.species .== \"Ononis_repens/spinosa_aggr.\", :species] .= \"Ononis spinosa L.\"\n    veg_df[veg_df.species .== \"Geranium_cf_pusillum\", :species] .= \"Geranium pusillum L.\"\n    veg_df[veg_df.species .== \"Primula_elatior/veris/aggr.\", :species] .= \"Primula elatior Hill\"\n\n    veg_species = unique(veg_df.species)\n    @rput veg_species\n    R\"\"\"\n    library(TNRS)\n    veg_species_df &lt;- TNRS(veg_species)\n    NaN\n    \"\"\"\n    @rget veg_species_df\n\n    veg_species_df = @chain veg_species_df begin\n        @rename begin\n        :species = :Accepted_species\n        :veg_orig_name = :Name_submitted\n        end\n        @subset :species .!== \"\"\n        @select :species :veg_orig_name\n    end\n\n    return veg_df, veg_species_df\nend\n\nfunction load_vegetation_date_df(path)\n    ep_plots = [\"$(explo)\" * lpad(i, 2, \"0\") for i in 1:50 for explo in [\"HEG\", \"SEG\", \"AEG\"]]\n    plot_df = DataFrame(plotID = ep_plots)\n\n    datasets = [\"vegetation_header_data_$y.csv\" for y in 2009:2021]\n\n    date_col = [fill(:Date, 2)...\n        fill(:date, 3)...\n        fill(missing, 4)...\n        fill(:date_releves, 4)...]\n    id_cols = [:EPID\n        fill(:EpPlotID, 8)...\n        fill(:Ep_PlotID, 4)...]\n    dfs = []\n\n    for (i, file) in enumerate(datasets)\n        df = CSV.read(path * file,\n            DataFrame;\n            missingstring = [\"\", \"NA\"])\n\n        if ismissing(date_col[i])\n            doy = df.day_of_year\n            doy[ismissing.(doy)] .= mean(.!ismissing(doy))\n            df.date = @. Dates.Date(df.year) + Dates.Day(doy)\n        else\n            df.date = df[:, date_col[i]]\n        end\n\n        df = @chain df begin\n            @transform :plotID = convert_id.($(id_cols[i]))\n            @select :plotID :date\n            rightjoin(plot_df, on = :plotID)\n        end\n\n        if any(ismissing.(df.date))\n            selected_dates = df[.!ismissing.(df.date), :date]\n            year = Dates.year(selected_dates[1])\n            mean_doy = Int(median(Dates.dayofyear.(selected_dates)))\n            df[ismissing.(df.date), :date] .= Dates.Date(year) + Dates.Day(mean_doy)\n        end\n\n        unique!(df, :plotID)\n\n        # @show length(unique(df.plotID))\n        push!(dfs, df)\n    end\n    date_df = vcat(dfs...)\n    date_df.year = Dates.year.(date_df.date)\n    date_df.numeric_date = to_numeric.(date_df.date)\n    return date_df\nend\n\n\n\n\n\n\n\n\n\n\n\nDescription\nData source\n\n\n\n\nVegetation records\ndata: Hinderling and Keller (2023), sampling date: Prati et al. (2017) Schmitt et al. (2017) Schmitt, Prati, and Fischer (2018a) Schmitt and Fischer (2018) Schmitt, Prati, and Fischer (2018b) Fischer, Hinderling, Schäfer, et al. (2023a) Fischer, Hinderling, Schäfer, et al. (2023b) Fischer, Schäfer, et al. (2023) Schäfer, Prati, and Fischer (2023) Bolliger, Hinderling, et al. (2023) Fischer, Hinderling, Bolliger, et al. (2023) Bolliger, Prati, et al. (2023) Prati and Bolliger (2023) Prati (2023)\n\n\nSpecific leaf area [m² g⁻¹]\nPrati, Goßner, and Neff (2021)\n\n\nArbuscular mycorrhizal colonisation [-]\nBergmann and Rillig (2022)\n\n\nRoot surface area / belowground biomass [m² g⁻¹]\nBergmann and Rillig (2022)\n\n\nPotential plant height [m]\nKleyer et al. (2008)\n\n\nLeaf nitrogen / leaf mass [mg g⁻¹]\nKattge et al. (2020)\n\n\nAboveground biomass / total biomass [-]\nBergmann and Rillig (2022)\n\n\n\nVegetation data set with exact dates was joined with species mean trait values to calculate community weighted mean traits for each plot and year.\n\n\n\n\n\n\n\nVariable\nDescription\n\n\n\n\nCWM_sla[t, plot]\nSpecific leaf area [m² g⁻¹]\n\n\nCWM_amc[t, plot]\nArbuscular mycorrhizal colonisation [-]\n\n\nCWM_srsa[t, plot]\nRoot surface area / belowground biomass [m² g⁻¹]\n\n\nCWM_height[t, plot]\nPlant height [m]\n\n\nCWM_lnc[t, plot]\nLeaf nitrogen / leaf mass [mg g⁻¹]\n\n\nCWM_abp[t, plot]\nAboveground biomass / total biomass [-]",
    "crumbs": [
      "Data of the Biodiversity Exploratories"
    ]
  },
  {
    "objectID": "parameter_fixed.html",
    "href": "parameter_fixed.html",
    "title": "Fixed parameter",
    "section": "",
    "text": "Fixed parameters and the references for their values\n\n\nParameter\nValue\nUnit\nReference\n\n\n\n\n\\(RUE_{\\max}\\)\n0.003\n\\(kg \\cdot MJ^{-1}\\)\nSchapendonk et al. (1998)\n\n\n\\(k\\)\n0.6\n\\(-\\)\nSchapendonk et al. (1998)\n\n\n\\(\\gamma_1\\)\n4.45 ⋅ 10⁻⁶\n\\(MJ^{-1}\\cdot ha\\)\nSchapendonk et al. (1998)\n\n\n\\(\\gamma_2\\)\n5 ⋅ 10⁴\n\\(MJ^{-1}\\cdot ha\\)\nSchapendonk et al. (1998)\n\n\n\\(T_0\\)\n4\n\\(°C\\)\nJouven, Carrere, and Baumont (2006)\n\n\n\\(T_1\\)\n10\n\\(°C\\)\nJouven, Carrere, and Baumont (2006)\n\n\n\\(T_2\\)\n20\n\\(°C\\)\nJouven, Carrere, and Baumont (2006)\n\n\n\\(T_3\\)\n35\n\\(°C\\)\nJouven, Carrere, and Baumont (2006)\n\n\n\\(ST_1\\)\n775\n\\(°C\\)\nJouven, Carrere, and Baumont (2006)\n\n\n\\(ST_2\\)\n1450\n\\(°C\\)\nJouven, Carrere, and Baumont (2006)\n\n\n\\(\\Psi_1\\)\n775\n\\(°C\\)\nMoulin et al. (2021)\n\n\n\\(\\Psi_2\\)\n3000\n\\(°C\\)\nMoulin et al. (2021)\n\n\n\\(\\kappa\\)\n22\n\\(kg \\cdot d^{-1}\\)\nGillet (2008)\n\n\n\\(N_{\\max}\\)\n35\n\\(g \\cdot kg^{-1}\\)\nfixed by me",
    "crumbs": [
      "Parameter",
      "Fixed parameter"
    ]
  },
  {
    "objectID": "parameter_fixed.html#references",
    "href": "parameter_fixed.html#references",
    "title": "Fixed parameter",
    "section": "",
    "text": "Fixed parameters and the references for their values\n\n\nParameter\nValue\nUnit\nReference\n\n\n\n\n\\(RUE_{\\max}\\)\n0.003\n\\(kg \\cdot MJ^{-1}\\)\nSchapendonk et al. (1998)\n\n\n\\(k\\)\n0.6\n\\(-\\)\nSchapendonk et al. (1998)\n\n\n\\(\\gamma_1\\)\n4.45 ⋅ 10⁻⁶\n\\(MJ^{-1}\\cdot ha\\)\nSchapendonk et al. (1998)\n\n\n\\(\\gamma_2\\)\n5 ⋅ 10⁴\n\\(MJ^{-1}\\cdot ha\\)\nSchapendonk et al. (1998)\n\n\n\\(T_0\\)\n4\n\\(°C\\)\nJouven, Carrere, and Baumont (2006)\n\n\n\\(T_1\\)\n10\n\\(°C\\)\nJouven, Carrere, and Baumont (2006)\n\n\n\\(T_2\\)\n20\n\\(°C\\)\nJouven, Carrere, and Baumont (2006)\n\n\n\\(T_3\\)\n35\n\\(°C\\)\nJouven, Carrere, and Baumont (2006)\n\n\n\\(ST_1\\)\n775\n\\(°C\\)\nJouven, Carrere, and Baumont (2006)\n\n\n\\(ST_2\\)\n1450\n\\(°C\\)\nJouven, Carrere, and Baumont (2006)\n\n\n\\(\\Psi_1\\)\n775\n\\(°C\\)\nMoulin et al. (2021)\n\n\n\\(\\Psi_2\\)\n3000\n\\(°C\\)\nMoulin et al. (2021)\n\n\n\\(\\kappa\\)\n22\n\\(kg \\cdot d^{-1}\\)\nGillet (2008)\n\n\n\\(N_{\\max}\\)\n35\n\\(g \\cdot kg^{-1}\\)\nfixed by me",
    "crumbs": [
      "Parameter",
      "Fixed parameter"
    ]
  },
  {
    "objectID": "parameter_fixed.html#read-from-the-calibration-object",
    "href": "parameter_fixed.html#read-from-the-calibration-object",
    "title": "Fixed parameter",
    "section": "2 Read from the calibration object",
    "text": "2 Read from the calibration object\n\n\nCode\nusing PrettyTables\n\ninclude(\"scripts/calibration/0_calibration_object.jl\")\nbe_opt = BE_optimization()\n\npretty_table(HTML, [String.(collect(keys(be_opt.fixed_parameter))) collect(be_opt.fixed_parameter)]; \n             header = [\"Parameter\", \"Value\"])\n\n\n\n\n\nParameter\nValue\n\n\n\n\nγ_RUEmax\n0.003 kg MJ^-1\n\n\nγ_RUE_k\n0.6\n\n\nγ_RAD1\n4.45e-6 ha MJ^-1\n\n\nγ_RAD2\n50000.0 MJ ha^-1\n\n\nω_TEMP_T1\n4.0 °C\n\n\nω_TEMP_T2\n10.0 °C\n\n\nω_TEMP_T3\n20.0 °C\n\n\nω_TEMP_T4\n35.0 °C\n\n\nκ_GRZ\n22.0 kg\n\n\nψ_SEN_ST2\n3000.0 °C\n\n\nϵ_GRZ_minH\n0.05 m\n\n\nϕ_amc\n0.108293\n\n\nϕ_rsa\n0.0683575 m^2 g^-1\n\n\nϕ_sla\n0.008808 m^2 g^-1\n\n\nα_NUT_Nmax\n35.0 g kg^-1\n\n\nη_GRZ\n2.0\n\n\nα_NUT_maxadj\n10.0\n\n\nβ_LIG_H\nNaN",
    "crumbs": [
      "Parameter",
      "Fixed parameter"
    ]
  }
]